# -*- coding: utf-8 -*-
"""
Display Functions Module
------------------------
Contains all display/UI functions for the portfolio tracker.
"""

from typing import Dict, Any, List, Optional, Tuple
from colorama import Fore, Style
from tabulate import tabulate
from utils.helpers import (
    format_currency,
    print_header,
    print_error,
    get_menu_choice,
    safe_float_convert,
)
from utils.display_theme import theme
from utils.enhanced_price_service import enhanced_price_service
from models.custom_coins import CustomCoinTracker
from datetime import datetime
from config.constants import SUPPORTED_CHAINS, SUPPORTED_CRYPTO_CURRENCIES_FOR_DISPLAY
import os
from pathlib import Path
import json
from collections import defaultdict


def display_exchange_detailed_breakdown(
    exchange_name: str, detailed_data: Optional[Dict[str, Any]], failed_sources: List[str]
):
    """Clean exchange breakdown with improved formatting."""
    
    if exchange_name in failed_sources:
        print(f"\n{theme.PRIMARY}{exchange_name} Status{theme.RESET}")
        print("Failed to fetch data")
        return

    if detailed_data is None:
        print(f"\n{theme.PRIMARY}{exchange_name} Status{theme.RESET}")
        print("Detailed breakdown not available")
        return

    # Safe handling of total equity
    total_equity = detailed_data.get("total_equity", 0) or 0
    
    if exchange_name.lower() == "binance":
        print(f"\n{theme.PRIMARY}Binance Spot Account{theme.RESET}")
        print(f"Spot Equity: {format_currency(total_equity)}")
        print("See account types above for complete balance")
    else:
        print(f"\n{theme.PRIMARY}{exchange_name} Detail{theme.RESET}")
        print(f"Total Equity: {format_currency(total_equity)}")

    assets = detailed_data.get("assets", [])[:10]  # Show top 10 assets

    if assets:
        print("\nTop Holdings")
        print("‚îÄ" * 20)
        
        def format_balance(value, decimals=6):
            """Smart balance formatting"""
            if value >= 1:
                return f"{value:,.4f}"
            elif value >= 0.01:
                return f"{value:.6f}"
            else:
                return f"{value:.8f}"
        
        # Prepare table data based on exchange type
        table_data = []
        headers = ["Asset", "Balance", "USD Value"]
        
        if exchange_name.lower() == "okx":
            headers.append("Available")
            for asset in assets:
                coin = asset.get("coin", "N/A")
                equity = asset.get("equity", 0) or 0
                available = asset.get("available", 0) or 0
                clean_equity = f"${equity:,.0f}" if equity >= 1 else f"${equity:.3f}"
                
                table_data.append([
                    coin,
                    format_balance(equity),
                    clean_equity,
                    format_balance(available)
                ])
                
        elif exchange_name.lower() == "binance":
            headers.extend(["Available", "Locked"])
            for asset in assets:
                coin = asset.get("coin", "N/A")
                total_val = asset.get("total", 0) or 0
                available = asset.get("free", 0) or 0
                locked = asset.get("locked", 0) or 0
                usd_value = asset.get("usd_value", 0) or 0
                clean_usd = f"${usd_value:,.0f}" if usd_value >= 1 else f"${usd_value:.3f}"

                table_data.append([
                    coin,
                    format_balance(total_val),
                    clean_usd,
                    format_balance(available),
                    format_balance(locked)
                ])
                
        elif exchange_name.lower() == "bybit":
            headers.append("Available")
            for asset in assets:
                coin = asset.get("coin", "N/A")
                total_val = asset.get("total", asset.get("equity", 0)) or 0
                usd_value = asset.get("usd_value", asset.get("equity", 0)) or 0
                available = asset.get("free", asset.get("available", 0)) or 0
                clean_usd = f"${usd_value:,.0f}" if usd_value >= 1 else f"${usd_value:.3f}"

                table_data.append([
                    coin,
                    format_balance(total_val),
                    clean_usd,
                    format_balance(available)
                ])
                
        elif exchange_name.lower() == "backpack":
            headers.extend(["Available", "Locked"])
            for asset in assets:
                coin = asset.get("coin", "N/A")
                total_val = asset.get("total", 0) or 0
                available = asset.get("available", 0) or 0
                locked = asset.get("locked", 0) or 0
                usd_value = asset.get("usd_value", 0) or 0
                clean_usd = f"${usd_value:,.0f}" if usd_value >= 1 else f"${usd_value:.3f}"

                table_data.append([
                    coin,
                    format_balance(total_val),
                    clean_usd,
                    format_balance(available),
                    format_balance(locked)
                ])

        if table_data:
            print(f"\n{tabulate(table_data, headers=headers, tablefmt='simple', numalign='right', stralign='left')}")

        total_assets = len(detailed_data.get("assets", []))
        if total_assets > 10 and exchange_name.lower() != "backpack":
            print(f"\n... and {total_assets - 10} more assets")
    else:
        print("\nNo assets to display")
    
    print()


def display_comprehensive_overview(metrics: Dict[str, Any], source_info: str = "Live Data"):
    """Enhanced portfolio overview with improved visual design."""
    print_header(f"Portfolio Overview ‚Ä¢ {source_info}")

    total_value = metrics.get("total_portfolio_value", 0.0)
    adjusted_value = metrics.get("adjusted_portfolio_value", 0.0)
    offset = metrics.get("balance_offset", 0.0)
    crypto_prices = metrics.get("crypto_prices", {})
    timestamp_str = metrics.get("timestamp", "N/A")
    failed_sources = metrics.get("failed_sources", [])

    try:
        dt_obj = datetime.fromisoformat(timestamp_str.replace("Z", "+00:00"))
        display_ts = dt_obj.strftime("%Y-%m-%d %H:%M:%S UTC")
    except ValueError:
        display_ts = timestamp_str

    # Remove the timestamp display line as requested by user
    
    if crypto_prices:
        print(f"\n{theme.SUBTLE}üìä Market data captured at time of analysis{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * 60}{theme.RESET}")
    else:
        print(f"\n{theme.SUBTLE}{'‚îÄ' * 60}{theme.RESET}")

    # Failure Summary with better visibility
    if failed_sources:
        print(f"\n{theme.WARNING}‚ö†  Data Issues: {', '.join(failed_sources)} (totals may be incomplete){theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * 60}{theme.RESET}")

    # Enhanced Portfolio Values Section
    print(f"\n{theme.PRIMARY}üí∞ PORTFOLIO VALUE{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 20}{theme.RESET}")

    print(f"Total Value:      {theme.ACCENT}{format_currency(total_value)}{theme.RESET}")

    if offset > 0:
        print(f"Applied Offset:   {theme.WARNING}-{format_currency(offset)}{theme.RESET}")
        print(f"Net Portfolio:    {theme.SUCCESS}{format_currency(adjusted_value)}{theme.RESET}")
    else:
        print(f"Applied Offset:   {theme.SUBTLE}{format_currency(offset)}{theme.RESET}")
        print(f"Net Portfolio:    {theme.SUCCESS}{format_currency(adjusted_value)}{theme.RESET}")

    # --- Distribution Summary ---
    total_cex = metrics.get("total_cex_balance", 0.0)
    total_defi = metrics.get("total_defi_balance", 0.0)

    print(f"\n{theme.PRIMARY}ALLOCATION{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 12}{theme.RESET}")

    if total_value > 0:
        cex_pct = (total_cex / total_value) * 100
        defi_pct = (total_defi / total_value) * 100
        print(f"Centralized:      {theme.ACCENT}{format_currency(total_cex)} ({cex_pct:.1f}%){theme.RESET}")
        print(f"DeFi/Wallets:     {theme.ACCENT}{format_currency(total_defi)} ({defi_pct:.1f}%){theme.RESET}")
    else:
        print(f"Centralized:      {theme.ACCENT}{format_currency(total_cex)}{theme.RESET}")
        print(f"DeFi/Wallets:     {theme.ACCENT}{format_currency(total_defi)}{theme.RESET}")

    # --- Platform Breakdown (Clean Table) ---
    print(f"\n{theme.PRIMARY}PLATFORM BREAKDOWN{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 20}{theme.RESET}")

    headers = [f"{theme.PRIMARY}Platform{theme.RESET}", f"{theme.PRIMARY}Balance{theme.RESET}", f"{theme.PRIMARY}Share{theme.RESET}"]
    data = []
    sources = [
        "Binance",
        "OKX",
        "Bybit",
        "Backpack",
        "Ethereum",
        "Bitcoin",
        "NEAR",
        "Aptos",
        "Solana",
        "Hyperliquid",
        "Lighter",
    ]
    grand_total_for_perc = total_value if total_value > 0 else 1

    for source in sources:
        key = source.lower()
        balance = metrics.get(key)

        if balance is not None and balance > 1e-3:
            percentage = (balance / grand_total_for_perc) * 100

            # Color coding by platform type
            if source in ["Binance", "OKX", "Bybit", "Backpack"]:
                platform_color = theme.ACCENT
            elif source in ["Ethereum", "Bitcoin", "NEAR", "Aptos", "Solana"]:
                platform_color = theme.SUCCESS
            else:  # Derivatives platforms
                platform_color = theme.WARNING

            data.append(
                [
                    f"{platform_color}{source}{theme.RESET}",
                    f"{theme.PRIMARY}{format_currency(balance)}{theme.RESET}",
                    f"{theme.SUBTLE}{percentage:.1f}%{theme.RESET}",
                    balance,  # For sorting
                ]
            )
        elif source in failed_sources:
            data.append(
                [f"{theme.ERROR}{source} (Error){theme.RESET}", f"{theme.ERROR}N/A{theme.RESET}", f"{theme.ERROR}N/A{theme.RESET}", -1]
            )

    if data:
        # Sort by balance descending
        data.sort(key=lambda row: row[3], reverse=True)
        # Remove raw balance before displaying
        display_data = [row[:-1] for row in data]
        print(
            tabulate(
                display_data, headers=headers, tablefmt="simple", numalign="right", stralign="left"
            )
        )
    else:
        print(f"{theme.SUBTLE}No platform data available{theme.RESET}")

    # --- Market Prices ---
    btc_price = crypto_prices.get("BTC")
    eth_price = crypto_prices.get("ETH")
    sol_price = crypto_prices.get("SOL")
    near_price = crypto_prices.get("NEAR")
    apt_price = crypto_prices.get("APT")

    # Get custom coin data for integration
    custom_coin_data_from_metrics = metrics.get("custom_coin_data", {}) # Renamed to avoid conflict
    custom_coin_prices = metrics.get("custom_coin_prices", {})
    
    # Ensure custom_coins_data is a dictionary
    custom_coins_list = custom_coin_data_from_metrics.get("custom_coins_data", {})
    if not isinstance(custom_coins_list, dict):
        custom_coins_list = {}


    # Display market prices with more prominence and all supported currencies
    price_available = any([
        btc_price and btc_price > 0, 
        eth_price and eth_price > 0, 
        sol_price and sol_price > 0, 
        near_price and near_price > 0, 
        apt_price and apt_price > 0
    ])
    
    # Check if we have custom coin prices to add
    custom_prices_available = any(
        custom_coin_prices.get(symbol) and custom_coin_prices.get(symbol) > 0 
        for symbol in custom_coins_list.keys()
    )
    
    if price_available or custom_prices_available:
        print(f"\n{theme.PRIMARY}üìà MARKET SNAPSHOT{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * 20}{theme.RESET}")

        price_data_table = [] # Renamed to avoid conflict with user's example
        
        # Add major cryptocurrencies first
        if btc_price and btc_price > 0:
            price_data_table.append([f"{theme.ACCENT}Bitcoin (BTC){theme.RESET}", f"{theme.SUCCESS}{format_currency(btc_price)}{theme.RESET}"])
        if eth_price and eth_price > 0:
            price_data_table.append([f"{theme.ACCENT}Ethereum (ETH){theme.RESET}", f"{theme.SUCCESS}{format_currency(eth_price)}{theme.RESET}"])
        if sol_price and sol_price > 0:
            price_data_table.append([f"{theme.ACCENT}Solana (SOL){theme.RESET}", f"{theme.SUCCESS}{format_currency(sol_price)}{theme.RESET}"])
        if near_price and near_price > 0:
            price_data_table.append([f"{theme.ACCENT}NEAR Protocol (NEAR){theme.RESET}", f"{theme.SUCCESS}{format_currency(near_price)}{theme.RESET}"])
        if apt_price and apt_price > 0:
            price_data_table.append([f"{theme.ACCENT}Aptos (APT){theme.RESET}", f"{theme.SUCCESS}{format_currency(apt_price)}{theme.RESET}"])

        # Add custom cryptocurrencies with prices
        for symbol, coin_info in custom_coins_list.items():
            # Ensure coin_info is a dictionary
            if not isinstance(coin_info, dict):
                continue

            last_price = custom_coin_prices.get(symbol)
            name = coin_info.get('name', symbol)
            
            if last_price and last_price > 0:
                # Format: "Name (SYMBOL)" or just "SYMBOL" if no name or name is same as symbol
                display_name_str = symbol # Default to symbol
                if name and name.lower() != symbol.lower():
                    display_name_str = f"{name.capitalize()} ({symbol.upper()})"
                else:
                    # If name is same as symbol, try to capitalize symbol or use as is
                    display_name_str = f"{symbol.capitalize()} ({symbol.upper()})" if len(symbol) > 1 else symbol.upper()

                # Adjust formatting for very small prices
                price_display_str = f"{format_currency(last_price)}" 
                if 0 < last_price < 0.01:
                    price_display_str = f"${last_price:.8f}" # Show more precision
                elif last_price == 0: # Explicitly show $0.00 if it's truly zero after fetch
                     price_display_str = "$0.00"

                price_data_table.append([f"{theme.ACCENT}{display_name_str}{theme.RESET}", f"{theme.SUCCESS}{price_display_str}{theme.RESET}"])
            elif custom_coin_data_from_metrics.get("custom_coins_count", 0) > 0: # Only show N/A if it was intended to be tracked
                display_name_str = symbol
                if name and name.lower() != symbol.lower():
                    display_name_str = f"{name.capitalize()} ({symbol.upper()})"
                else:
                    display_name_str = f"{symbol.capitalize()} ({symbol.upper()})" if len(symbol) > 1 else symbol.upper()
                price_data_table.append([f"{theme.ACCENT}{display_name_str}{theme.RESET}", f"{theme.ERROR}No Price{theme.RESET}"])


        if price_data_table:
            print(
                tabulate(
                    price_data_table,
                    headers=[f"{theme.PRIMARY}Cryptocurrency{theme.RESET}", f"{theme.PRIMARY}Price (USD){theme.RESET}"],
                    tablefmt="simple",
                    numalign="right",
                    stralign="left",
                )
            )

    # --- Portfolio in Crypto Terms ---
    if adjusted_value > 0 and price_available:
        print(f"\n{theme.PRIMARY}üí∞ PORTFOLIO VALUE IN CRYPTO{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * 28}{theme.RESET}")

        # Create crypto portfolio table with safe division
        crypto_portfolio_data = []
        if btc_price and btc_price > 0:
            crypto_portfolio_data.append([
                f"{theme.WARNING}Bitcoin{theme.RESET}", 
                f"{theme.ACCENT}{adjusted_value / btc_price:.6f} BTC{theme.RESET}"
            ])
        if eth_price and eth_price > 0:
            crypto_portfolio_data.append([
                f"{theme.WARNING}Ethereum{theme.RESET}", 
                f"{theme.ACCENT}{adjusted_value / eth_price:.4f} ETH{theme.RESET}"
            ])
        if sol_price and sol_price > 0:
            crypto_portfolio_data.append([
                f"{theme.WARNING}Solana{theme.RESET}", 
                f"{theme.ACCENT}{adjusted_value / sol_price:.2f} SOL{theme.RESET}"
            ])
        if near_price and near_price > 0:
            crypto_portfolio_data.append([
                f"{theme.WARNING}NEAR{theme.RESET}", 
                f"{theme.ACCENT}{adjusted_value / near_price:.2f} NEAR{theme.RESET}"
            ])
        if apt_price and apt_price > 0:
            crypto_portfolio_data.append([
                f"{theme.WARNING}Aptos{theme.RESET}", 
                f"{theme.ACCENT}{adjusted_value / apt_price:.2f} APT{theme.RESET}"
            ])

        if crypto_portfolio_data:
            print(
                tabulate(
                    crypto_portfolio_data,
                    headers=[f"{theme.PRIMARY}Currency{theme.RESET}", f"{theme.PRIMARY}Portfolio Value{theme.RESET}"],
                    tablefmt="simple",
                    numalign="right",
                    stralign="left",
                )
            )

    # --- Risk Assessment ---
    print(f"\n{theme.PRIMARY}RISK ASSESSMENT{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 17}{theme.RESET}")

    if total_value > 0:
        cex_percentage = (total_cex / total_value) * 100
        if cex_percentage > 80:
            print(
                f"{theme.ERROR}‚Ä¢ High CEX concentration ({cex_percentage:.1f}%) - Consider diversification{theme.RESET}"
            )
        elif cex_percentage > 60:
            print(f"{theme.WARNING}‚Ä¢ Moderate CEX concentration ({cex_percentage:.1f}%){theme.RESET}")
        else:
            print(f"{theme.SUCCESS}‚Ä¢ Balanced allocation between CEX and DeFi{theme.RESET}")

        if offset > 0:
            offset_pct = (offset / total_value) * 100
            if offset_pct > 15:
                print(f"{theme.WARNING}‚Ä¢ Large offset applied ({offset_pct:.1f}% of total){theme.RESET}")
    else:
        print(f"{theme.SUBTLE}‚Ä¢ Portfolio assessment unavailable{theme.RESET}")

    print()  # Final spacing


def display_asset_distribution(metrics: Dict[str, Any]):
    """Clean asset distribution chart with professional styling."""
    print_header("Portfolio Distribution Analysis")

    total_value = metrics.get("total_portfolio_value", 0.0)
    if total_value <= 0:
        print(f"{theme.SUBTLE}No positive asset values to display distribution for.{theme.RESET}")
        return

    portfolio_data = []
    sources = [
        "Binance", "OKX", "Bybit", "Backpack",
        "Ethereum", "Bitcoin", "NEAR", "Aptos", "Solana",
        "Hyperliquid", "Lighter"
    ]

    for source in sources:
        key = source.lower()
        balance = metrics.get(key)
        if balance is not None and balance > 1e-3:
            portfolio_data.append((source, balance))

    if not portfolio_data:
        print(f"{theme.SUBTLE}No valid asset data for distribution chart.{theme.RESET}")
        return

    portfolio_data.sort(key=lambda x: x[1], reverse=True)
    included_total = sum(item[1] for item in portfolio_data)
    
    if included_total <= 0:
        print(f"{theme.SUBTLE}Included asset total is zero, cannot generate chart.{theme.RESET}")
        return

    chart_data = [(name, value, (value / included_total) * 100) for name, value in portfolio_data]

    # Clean header
    print(f"\n{theme.PRIMARY}Portfolio Distribution{theme.RESET}")
    print(f"Total Value: {format_currency(included_total)}")
    print("‚îÄ" * 60)

    # Create simple table data
    table_data = []
    
    for label, value, percentage in chart_data:
        # Platform type indicators
        if label in ["Binance", "OKX", "Bybit", "Backpack"]:
            platform_type = "CEX"
        elif label in ["Ethereum", "Bitcoin", "NEAR", "Aptos", "Solana"]:
            platform_type = "L1"
        else:
            platform_type = "DeFi"
        
        # Clean progress bar
        bar_width = 20
        filled_width = int(percentage * bar_width / 100)
        progress_bar = "‚ñà" * filled_width + "‚ñë" * (bar_width - filled_width)
        
        # Format value
        clean_value = f"${value:,.0f}" if value >= 1 else f"${value:.2f}"
        
        table_data.append([
            f"{platform_type:>4} {label}",
            clean_value,
            progress_bar,
            f"{percentage:5.1f}%"
        ])

    # Simple table with grid format for perfect alignment
    headers = ["Platform", "Value", "Distribution", "Share"]
    print(f"\n{tabulate(table_data, headers=headers, tablefmt='grid')}")

    # Simple summary
    largest_allocation = max(chart_data, key=lambda x: x[2])
    largest_pct = largest_allocation[2]
    
    print(f"\nLargest allocation: {largest_allocation[0]} ({largest_pct:.1f}%)")
    if largest_pct > 70:
        print("‚ö† Consider diversifying for reduced risk")
    
    print()


def display_wallet_balances(portfolio_metrics: Dict[str, Any]):
    """Enhanced wallet balances display with improved formatting and theming."""
    print_header("Wallet Platform Balances")

    # Extract wallet platform data from portfolio metrics
    wallet_platform_data_raw = portfolio_metrics.get("wallet_platform_data_raw", [])
    
    if not wallet_platform_data_raw:
        print(f"{theme.SUBTLE}No wallet data available. Check your configuration.{theme.RESET}")
        return

    # Separate Hyperliquid balances so they can be merged back into the owning wallets
    from collections import defaultdict
    hyperliquid_balances: Dict[str, float] = defaultdict(float)
    for entry in wallet_platform_data_raw:
        if entry.get("platform") == "hyperliquid":
            address = entry.get("address", "").lower()
            try:
                hyperliquid_balances[address] += float(entry.get("total_balance", 0) or 0.0)
            except (TypeError, ValueError):
                continue

    # Keep only chain-specific wallet entries for the main table
    wallet_platform_data = [entry for entry in wallet_platform_data_raw if entry.get("chain")]

    # Calculate total balance across all wallets
    total_all_wallets_usd = sum(
        (
            info.get("total_balance_usd", 0.0)
            if info.get("chain") == "solana"
            else info.get("total_balance", 0.0)
        ) or 0.0
        for info in wallet_platform_data
    ) + sum(hyperliquid_balances.values())

    # Enhanced header with emoji and better formatting
    print(f"\n{theme.PRIMARY}üíº PLATFORM OVERVIEW{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 19}{theme.RESET}")
    print(f"Total Portfolio Value: {theme.SUCCESS}{format_currency(total_all_wallets_usd)}{theme.RESET}")
    print(f"Active Wallets:        {theme.ACCENT}{len(wallet_platform_data)}{theme.RESET}")

    if total_all_wallets_usd == 0:
        print(f"\n{theme.WARNING}‚ö†Ô∏è  All wallet balances are zero or unavailable{theme.RESET}")
        return

    # Enhanced table headers
    headers = [
        f"{theme.PRIMARY}Address{theme.RESET}",
        f"{theme.PRIMARY}USD Balance{theme.RESET}",
        f"{theme.PRIMARY}Native Balance{theme.RESET}",
        f"{theme.PRIMARY}% of Total{theme.RESET}",
        f"{theme.PRIMARY}Details{theme.RESET}",
    ]

    table_data = []
    ethereum_wallets = []

    for info in wallet_platform_data:
        chain = info.get("chain", "unknown")
        address = info.get("address", "N/A")

        # Enhanced address formatting for different chains
        address_short = address
        if len(address) > 20:
            if chain in ["ethereum", "solana", "aptos"]:
                address_short = address[:8] + "..." + address[-6:]
            else:
                address_short = address[:8] + "..." + address[-6:]

        # Use the correct balance key depending on the chain
        balance_usd = (
            info.get("total_balance_usd", 0.0)
            if chain == "solana"
            else info.get("total_balance", 0.0)
        )
        # Ensure balance_usd is not None
        balance_usd = balance_usd or 0.0
        address_key = address.lower()
        hyper_extra = hyperliquid_balances.get(address_key, 0.0)
        if chain == "ethereum" and hyper_extra:
            balance_usd += hyper_extra
        
        percentage = (
            (balance_usd / total_all_wallets_usd) * 100 if total_all_wallets_usd > 0 and balance_usd else 0.0
        )

        # Chain-specific details formatting with enhanced styling
        if chain == "ethereum":
            native_balance_str = f"{theme.ERROR}Not Available{theme.RESET}"
            token_count = info.get('token_count', '?')
            protocol_count = info.get('protocol_count', '?')
            details_str = f"Tokens: {theme.ACCENT}{token_count}{theme.RESET}, Protocols: {theme.ACCENT}{protocol_count}{theme.RESET}"
            eth_info = info.copy()
            eth_info['total_balance'] = balance_usd
            if hyper_extra:
                eth_info['hyperliquid_balance'] = hyper_extra
            ethereum_wallets.append(eth_info)
        elif chain == "bitcoin":
            btc_bal = info.get("balance_btc", 0)
            native_balance_str = f"{theme.WARNING}{btc_bal:.6f} BTC{theme.RESET}"
            tx_count = info.get('transaction_count', '?')
            details_str = f"Transactions: {theme.ACCENT}{tx_count}{theme.RESET}"
        elif chain == "near":
            near_bal = info.get("balance_near", 0)
            native_balance_str = f"{theme.ACCENT}{near_bal:.4f} NEAR{theme.RESET}"
            storage = info.get('storage_usage', '?')
            details_str = f"Storage: {theme.ACCENT}{storage}{theme.RESET} bytes"
        elif chain == "aptos":
            apt_bal = info.get("balance_apt", 0)
            native_balance_str = f"{theme.SUCCESS}{apt_bal:.6f} APT{theme.RESET}"
            token_count = len(info.get("token_balances", {}))
            seq_num = info.get('sequence_number', '?')
            details_str = f"Tokens: {theme.ACCENT}{token_count}{theme.RESET}, Seq: {theme.ACCENT}{seq_num}{theme.RESET}"
        elif chain == "solana":
            sol_bal = info.get("balance_sol", 0)
            native_balance_str = f"{theme.PRIMARY}{sol_bal:.4f} SOL{theme.RESET}"
            token_count = sum(
                1 for bal in info.get("token_balances", {}).values() if bal > 1e-6
            )
            details_str = f"SPL Tokens: {theme.ACCENT}{token_count}{theme.RESET}"
        else:
            native_balance_str = f"{theme.SUBTLE}N/A{theme.RESET}"
            source = info.get('source', 'N/A')
            details_str = f"Source: {theme.ACCENT}{source}{theme.RESET}"

        table_data.append(
            [
                f"{theme.ACCENT}{address_short}{theme.RESET}",
                f"{theme.SUCCESS}{format_currency(balance_usd)}{theme.RESET}",
                native_balance_str,
                f"{theme.SUBTLE}{percentage:.1f}%{theme.RESET}",
                f"{theme.SUBTLE}{details_str}{theme.RESET}",
                balance_usd,  # For sorting
            ]
        )

    # Sort by balance descending
    table_data.sort(key=lambda row: row[5], reverse=True)
    # Remove raw balance before display
    display_table_data = [row[:-1] for row in table_data]
    print(
        tabulate(
            display_table_data,
            headers=headers,
            tablefmt="rounded_grid",  # Enhanced table style
            numalign="right",
            stralign="left",
        )
    )

    # Add submenu for detailed analysis
    quick_mode = False
    try:
        quick_mode = portfolio_metrics.get('quick_mode', False)
    except Exception:
        quick_mode = False

    if ethereum_wallets and not quick_mode:
        print(f"\n{theme.PRIMARY}üìä DETAILED ANALYSIS OPTIONS{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * 28}{theme.RESET}")
        print(f"{theme.ACCENT}1.{theme.RESET} {theme.PRIMARY}üîó View Detailed ETH Wallet Breakdown{theme.RESET} {theme.SUBTLE}‚Ä¢ Enhanced token & protocol analysis{theme.RESET}")
        print(f"{theme.ACCENT}2.{theme.RESET} {theme.SUBTLE}‚¨ÖÔ∏è Continue to Main Menu{theme.RESET}")
        
        choice = input(f"\n{theme.PRIMARY}Select option (1-2): {theme.RESET}").strip()
        
        if choice == "1":
            _display_detailed_eth_breakdown(ethereum_wallets, portfolio_metrics)

    print()  # Final spacing


def _display_detailed_eth_breakdown(ethereum_wallets: List[Dict[str, Any]], portfolio_metrics: Dict[str, Any]):
    """Display the detailed Ethereum wallet breakdown that was previously shown automatically."""
    from utils.display_theme import theme
    from utils.helpers import format_currency, safe_float_convert
    from tabulate import tabulate
    import os
    import json
    from pathlib import Path
    
    # Clear screen for better viewing
    os.system('clear' if os.name == 'posix' else 'cls')
    
    print(f"\n{theme.PRIMARY}üîó ETHEREUM WALLET EXPLORER{theme.RESET}")
    print(f"{theme.SUBTLE}{'=' * 27}{theme.RESET}")
    
    # Try to load enhanced data from portfolio metrics for detailed display
    try:
        # Check if we have enhanced data in any analysis folders
        enhanced_data = {}
        
        # Check if we have analysis folder context from past analysis viewing
        analysis_folder = portfolio_metrics.get('_analysis_folder')
        
        if analysis_folder and Path(analysis_folder).exists():
            # SPECIFIC ANALYSIS SESSION: Load from the exact folder
            analysis_path = Path(analysis_folder)
            json_files = list(analysis_path.glob("wallet_breakdown_0x*.json"))
            
            if json_files:
                # Load enhanced data for each address
                for json_file in json_files:
                    try:
                        with open(json_file, 'r') as f:
                            file_data = json.load(f)
                        
                        # Extract address from file data or filename
                        address = file_data.get('address')
                        if not address:
                            # Try to extract from filename
                            filename = json_file.name
                            if 'wallet_breakdown_0x' in filename:
                                address_part = filename.split('wallet_breakdown_')[1].split('.json')[0]
                                # Find matching full address
                                for eth_wallet in ethereum_wallets:
                                    full_addr = eth_wallet.get('address', '')
                                    if full_addr.lower().startswith(address_part.lower()):
                                        address = full_addr
                                        break
                        
                        if address:
                            enhanced_data[address] = file_data
                        
                    except Exception:
                        continue
            
            # FALLBACK: If no individual files found, try loading from eth_exposure_data in portfolio_metrics
            if not enhanced_data:
                print(f"{theme.INFO}üìÅ No individual wallet files found, trying eth_exposure_data fallback...{theme.RESET}")
                eth_exposure_data = portfolio_metrics.get('eth_exposure_data', {})
                for address, addr_data in eth_exposure_data.items():
                    if 'export_data' in addr_data:
                        enhanced_data[address] = addr_data['export_data']
                        print(f"{theme.SUCCESS}‚úÖ Loaded fallback data for {address[:8]}...{address[-6:]}{theme.RESET}")
        
        else:
            # NO SPECIFIC FOLDER: Search all organized folders (for live analysis or refresh)
            exported_data_path = Path("exported_data")
            
            if exported_data_path.exists():
                # Search in organized analysis folders first
                analysis_folders = list(exported_data_path.glob("analysis_*/"))
                json_files = []
                
                for analysis_folder_path in analysis_folders:
                    json_files.extend(analysis_folder_path.glob("wallet_breakdown_0x*.json"))
                
                # Also check root folder for legacy files
                json_files.extend(exported_data_path.glob("live_analysis_0x*.json"))
                json_files.extend(exported_data_path.glob("wallet_breakdown_0x*.json"))
                
                # Sort by modification time to get most recent first
                if json_files:
                    json_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)
                    
                    # Track which addresses we've actually loaded (not duplicates)
                    loaded_addresses = set()
                    
                    # Load enhanced data for each address
                    for json_file in json_files:
                        try:
                            with open(json_file, 'r') as f:
                                file_data = json.load(f)
                            
                            # Extract address from file data or filename
                            address = file_data.get('address')
                            if not address:
                                # Try to extract from filename
                                filename = json_file.name
                                if 'wallet_breakdown_0x' in filename:
                                    address_part = filename.split('wallet_breakdown_')[1].split('.json')[0]
                                elif 'live_analysis_0x' in filename:
                                    address_part = filename.split('_')[2]
                                else:
                                    continue
                                
                                # Find matching full address
                                for eth_wallet in ethereum_wallets:
                                    full_addr = eth_wallet.get('address', '')
                                    if full_addr.lower().startswith(address_part.lower()):
                                        address = full_addr
                                        break
                            
                            if address:
                                # Only load for new addresses (not overwrites)
                                if address not in loaded_addresses:
                                    enhanced_data[address] = file_data
                                    loaded_addresses.add(address)
                                else:
                                    # Silently overwrite with more recent data (files are sorted by mod time)
                                    enhanced_data[address] = file_data
                            
                        except Exception:
                            continue
    except Exception:
        enhanced_data = {}

    # Interactive submenu for detailed wallet exploration
    if enhanced_data:
        # Show clean summary of loaded data
        loaded_count = len(enhanced_data)
        total_wallets = len(ethereum_wallets)
        print(f"\n{theme.SUCCESS}‚úÖ Enhanced data loaded for {loaded_count}/{total_wallets} Ethereum wallets{theme.RESET}")
        
        while True:
            print(f"\n{theme.INFO}Select a wallet to view ALL tokens and protocols:{theme.RESET}")
            
            # Show wallet options
            for i, eth_wallet in enumerate(ethereum_wallets):
                address = eth_wallet.get('address', 'Unknown')
                address_short = f"{address[:8]}...{address[-6:]}" if len(address) > 14 else address
                balance_usd = eth_wallet.get('total_balance', 0.0)
                
                # Check if enhanced data is available
                has_data = address in enhanced_data
                status_icon = "‚úÖ" if has_data else "‚ùå"
                
                print(f"  {theme.ACCENT}{i+1}.{theme.RESET} {status_icon} {address_short} - {format_currency(balance_usd)}")
            
            # Check if combined analysis is available
            analysis_folder = portfolio_metrics.get('_analysis_folder')
            combined_available = False
            if analysis_folder:
                try:
                    from combined_wallet_integration import check_combined_wallet_availability
                    combined_available = check_combined_wallet_availability(analysis_folder)
                except Exception:
                    combined_available = False
            
            # Add combined portfolio option if available
            if combined_available:
                print(f"  {theme.ACCENT}{len(ethereum_wallets)+1}.{theme.RESET} üéØ {theme.PRIMARY}Combined Portfolio View{theme.RESET} {theme.SUBTLE}‚Ä¢ All wallets aggregated{theme.RESET}")
            
            print(f"  {theme.ACCENT}0.{theme.RESET} Return to wallet balances")
            
            max_choice = len(ethereum_wallets) + (1 if combined_available else 0)
            
            try:
                choice = input(f"\n{theme.PRIMARY}Enter your choice (0-{max_choice}): {theme.RESET}").strip()
                
                if choice == '0':
                    break
                
                # Check if it's the combined portfolio option
                if combined_available and choice == str(len(ethereum_wallets) + 1):
                    try:
                        from combined_wallet_integration import get_combined_wallet_file_path, display_combined_wallet_analysis
                        if analysis_folder:  # Type check to ensure it's not None
                            combined_file = get_combined_wallet_file_path(analysis_folder)
                            if combined_file:
                                display_combined_wallet_analysis(combined_file, portfolio_metrics)
                            else:
                                print(f"\n{theme.ERROR}‚ùå Failed to load combined portfolio data{theme.RESET}")
                                input(f"{theme.SUBTLE}Press Enter to continue...{theme.RESET}")
                        else:
                            print(f"\n{theme.ERROR}‚ùå No analysis folder available{theme.RESET}")
                            input(f"{theme.SUBTLE}Press Enter to continue...{theme.RESET}")
                    except Exception as e:
                        print(f"\n{theme.ERROR}‚ùå Error loading combined portfolio: {str(e)}{theme.RESET}")
                        input(f"{theme.SUBTLE}Press Enter to continue...{theme.RESET}")
                    continue
                
                wallet_index = int(choice) - 1
                if 0 <= wallet_index < len(ethereum_wallets):
                    selected_wallet = ethereum_wallets[wallet_index]
                    address = selected_wallet.get('address', '')
                    
                    if address in enhanced_data:
                        _display_complete_wallet_details(enhanced_data[address], address, portfolio_metrics)
                    else:
                        print(f"\n{theme.ERROR}‚ùå No enhanced data available for this wallet{theme.RESET}")
                        print(f"{theme.SUBTLE}Run live analysis to generate detailed data{theme.RESET}")
                else:
                    print(f"\n{theme.ERROR}‚ùå Invalid choice. Please select 0-{max_choice}{theme.RESET}")
            except (ValueError, KeyboardInterrupt):
                if choice.lower() in ['q', 'quit', 'exit']:
                    break
                print(f"\n{theme.ERROR}‚ùå Invalid input. Please enter a number or 'q' to quit{theme.RESET}")
            except Exception as e:
                print(f"\n{theme.ERROR}‚ùå Error: {str(e)}{theme.RESET}")
    else:
        print(f"\n{theme.ERROR}‚ùå NO ENHANCED DATA AVAILABLE{theme.RESET}")
        print(f"{theme.SUBTLE}Run a live analysis to generate enhanced wallet breakdowns{theme.RESET}")


def _display_wallet_summary_stats(tokens: List[Dict[str, Any]], protocols: List[Dict[str, Any]], show_detailed_breakdown: bool = True, show_summary: bool = True, show_stable_breakdown: bool = True):
    """Helper function to display summary statistics for a wallet."""
    from utils.display_theme import theme
    from utils.helpers import format_currency
    
    # Initialize variable to prevent UnboundLocalError
    has_negative_protocols = False
    
    # --- Enhanced Token Category Breakdown ---
    category_totals = {
        'stable': 0.0,
        'eth_exposure': 0.0,
        'eth_staking': 0.0,
        'other_crypto': 0.0,
        'lp_token': 0.0,
    }
    
    # Define a comprehensive set of base stablecoin symbols
    stablecoin_bases = {'USDC', 'USDT', 'DAI', 'FDUSD', 'USDE', 'FRAX', 'TUSD', 'PYUSD', 'GUSD', 'PAX', 'BUSD', 'GHO', 'CRVUSD'}
    
    # Additional stablecoin detection patterns
    stablecoin_patterns = ['USD']
    
    # Track individual stablecoins for detailed breakdown, organized by chain
    stablecoin_breakdown = {}
    # Track chains for stablecoins
    stablecoin_chains = {}

    # Track non-stable tokens for detailed breakdown
    nonstable_breakdown = {}
    nonstable_chains = {}
    nonstable_amounts = {}  # Track token amounts
    nonstable_amounts_by_chain = {}  # Track token amounts per chain

    def _is_mixed_symbol(symbol: str) -> bool:
        clean = (symbol or "").replace(" ", "").upper()
        if '+' in clean:
            parts = [part for part in clean.split('+') if part]
            if parts and all(
                part in stablecoin_bases or any(pattern in part for pattern in stablecoin_patterns)
                for part in parts
            ):
                return False
        return any(sep in clean for sep in ['/', '+', '-'])

    for token in tokens:
        symbol = token.get('symbol', '').upper()
        category = token.get('category', 'other_crypto')
        value = token.get('usd_value', 0)
        chain = token.get('chain', 'unknown').capitalize()
        
        # Check if the token is a stablecoin based on its symbol prefix or category
        is_stable = False
        if not _is_mixed_symbol(symbol):
            # Method 1: Check if token starts with known stablecoin bases
            for base in stablecoin_bases:
                if symbol.startswith(base):
                    is_stable = True
                    break
            
            # Method 2: Check if token has "USD" anywhere in the name
            if not is_stable:
                for pattern in stablecoin_patterns:
                    if pattern in symbol:
                        is_stable = True
                        break
        
        # Method 3: Check if token category is explicitly marked as stable
        if not is_stable and category == 'stable':
            is_stable = True
        
        if is_stable:
            # Add to stablecoin breakdown with chain info
            chain_key = f"{symbol}_{chain}"
            if chain_key in stablecoin_breakdown:
                stablecoin_breakdown[chain_key] += value
            else:
                stablecoin_breakdown[chain_key] = value
                stablecoin_chains[chain_key] = chain
            
            # Add to category totals
            category_totals['stable'] += value
        elif category in category_totals and category != 'other_crypto':
            # Handle specific non-stable categories
            chain_key = f"{symbol}_{chain}"
            if chain_key in nonstable_breakdown:
                nonstable_breakdown[chain_key] += value
            else:
                nonstable_breakdown[chain_key] = value
                nonstable_chains[chain_key] = chain
            
            # Track token amounts for the symbol, breakdown and totals handled above
            if symbol in nonstable_amounts:
                nonstable_amounts[symbol] += token.get('amount', 0)
            else:
                nonstable_amounts[symbol] = token.get('amount', 0)
                
            # Track token amount per chain for detailed breakdown of eth_exposure and similar categories
            nonstable_amounts_by_chain[chain_key] = nonstable_amounts_by_chain.get(chain_key, 0) + token.get('amount', 0)
            
            # Add to category totals for this specific category (e.g. eth_exposure, eth_staking, lp_token)
            category_totals[category] += value
        else:
            # Add to non-stable token breakdown
            chain_key = f"{symbol}_{chain}"
            if chain_key in nonstable_breakdown:
                nonstable_breakdown[chain_key] += value
            else:
                nonstable_breakdown[chain_key] = value
                nonstable_chains[chain_key] = chain
            
            # Track token amounts for the symbol
            if symbol in nonstable_amounts:
                nonstable_amounts[symbol] += token.get('amount', 0)
            else:
                nonstable_amounts[symbol] = token.get('amount', 0)

            # Track token amounts per chain
            nonstable_amounts_by_chain[chain_key] = nonstable_amounts_by_chain.get(chain_key, 0) + token.get('amount', 0)
                
            category_totals['other_crypto'] += value
    
    # Track for summary: eth_total and other_total as computed from tokens
    eth_total_for_summary = sum(
        v for k, v in nonstable_breakdown.items() if k.startswith('ETH_') and v >= 0.1
    )
    # Calculate non-stable total (all categories except stables)
    non_stable_total_direct = sum(category_totals.values()) - category_totals['stable']
    other_total_for_summary = max(non_stable_total_direct - eth_total_for_summary, 0)

    # If nothing found (edge-case), fall back to None so later logic can overwrite
    if eth_total_for_summary == 0:
        eth_total_for_summary = None
    if other_total_for_summary == 0 and non_stable_total_direct == 0:
        other_total_for_summary = None
    
    # Display detailed stablecoin breakdown if any stablecoins exist
    if show_detailed_breakdown and show_stable_breakdown and stablecoin_breakdown:
        print(f"\n{theme.INFO}Stablecoin Breakdown:{theme.RESET}")
        
        # Group by symbol first
        symbol_totals = {}
        dust_stables_total = 0.0
        
        for chain_key, value in stablecoin_breakdown.items():
            symbol = chain_key.split('_')[0]
            # Skip dust amounts in the symbol totals calculation
            if value < 0.1:
                dust_stables_total += value
                continue
                
            if symbol in symbol_totals:
                symbol_totals[symbol] += value
            else:
                symbol_totals[symbol] = value
        
        # Show symbol totals first (excluding dust)
        for symbol, value in sorted(symbol_totals.items(), key=lambda x: x[1], reverse=True):
            stable_percentage = (value / category_totals['stable'] * 100) if category_totals['stable'] > 0 else 0
            # Determine chains for this symbol
            chains_for_symbol = [ck for ck, cv in stablecoin_breakdown.items() if ck.startswith(f"{symbol}_") and cv >= 0.1]
            if len(chains_for_symbol) == 1:
                # Single-chain: symbol with chain info in parentheses
                chain_key = chains_for_symbol[0]
                chain = stablecoin_chains[chain_key]
                chain_icon = {"Ethereum": "‚ü†", "Arbitrum": "üîµ", "Polygon": "üü£", "Base": "üî∑", "Optimism": "üî¥", "Solana": "üåû"}.get(chain, "üîó")
                # Format: SYMBOL (ICON Chain): VALUE (PERCENT)
                print(f"  {symbol} ({chain_icon} {chain}): {theme.SUCCESS}{format_currency(value)}{theme.RESET} ({stable_percentage:.1f}%)")
            else:
                # Multi-chain: print summary and breakdown
                print(f"  {symbol}: {theme.SUCCESS}{format_currency(value)}{theme.RESET} ({stable_percentage:.1f}%)")
                for chain_key, chain_value in sorted(stablecoin_breakdown.items(), key=lambda x: x[1], reverse=True):
                    if chain_key.startswith(f"{symbol}_") and chain_value >= 0.1:
                        chain = stablecoin_chains[chain_key]
                        chain_percentage = (chain_value / value * 100) if value > 0 else 0
                        chain_icon = {"Ethereum": "‚ü†", "Arbitrum": "üîµ", "Polygon": "üü£", "Base": "üî∑", "Optimism": "üî¥", "Solana": "üåû"}.get(chain, "üîó")
                        print(f"    {chain_icon} {chain}: {theme.SUBTLE}{format_currency(chain_value)}{theme.RESET} ({chain_percentage:.1f}%)")
        
        # Show dust stables total if any
        if dust_stables_total > 0:
            dust_percentage = (dust_stables_total / category_totals['stable'] * 100) if category_totals['stable'] > 0 else 0
            print(f"  {theme.SUBTLE}Dust stables (<$0.1): {format_currency(dust_stables_total)} ({dust_percentage:.1f}%){theme.RESET}")
        
        print(f"  {theme.ACCENT}Total Stables: {format_currency(category_totals['stable'])}{theme.RESET}")
    
    # Display detailed non-stable token breakdown
    if show_detailed_breakdown and nonstable_breakdown:
        non_stable_total = sum(category_totals.values()) - category_totals['stable']
        print(f"\n{theme.INFO}Non-Stable Token Breakdown:{theme.RESET}")
        
        # Group by symbol first
        symbol_totals = {}
        dust_tokens_total = 0.0
        
        for chain_key, value in nonstable_breakdown.items():
            symbol = chain_key.split('_')[0]
            # Skip dust amounts in the symbol totals calculation
            if value < 0.1:
                dust_tokens_total += value
                continue
                
            if symbol in symbol_totals:
                symbol_totals[symbol] += value
            else:
                symbol_totals[symbol] = value

        # Fix percentage calculation: Use positive-only base when there are negative values
        # This ensures positive token percentages add up to 100% instead of over 100%
        symbol_totals_positive = sum(value for value in symbol_totals.values() if value > 0)
        has_negative_values = any(value < 0 for value in symbol_totals.values())
        if has_negative_values:
            # When there are negative values, use only positive values + positive dust for percentage base
            percentage_base = symbol_totals_positive + max(0, dust_tokens_total)
        else:
            # When all values are positive, use the original calculation
            percentage_base = non_stable_total if non_stable_total > 0 else symbol_totals_positive
        
        # Show all non-stable tokens sorted by value
        for symbol, value in sorted(symbol_totals.items(), key=lambda x: (x[1] < 0, -abs(x[1]))):
            # Skip tokens under $5 and aggregate into dust
            if abs(value) < 5:  # Use absolute value for dust threshold
                dust_tokens_total += value
                continue
                
            # Check if token has negative total value
            is_negative_token = value < 0
            token_percentage = (value / percentage_base * 100) if percentage_base and not is_negative_token else 0
            amount = nonstable_amounts.get(symbol, 0)
            amount_str = f"{amount:.6f}".rstrip('0').rstrip('.') if amount < 1 else f"{amount:,.4f}".rstrip('0').rstrip('.')
            # Determine token's chains
            chains_for_symbol = [ck for ck, cv in nonstable_breakdown.items() if ck.startswith(f"{symbol}_") and cv >= 0.1]
            if len(chains_for_symbol) == 1:
                # Single-chain: symbol with chain info in parentheses
                chain_key = chains_for_symbol[0]
                chain = nonstable_chains[chain_key]
                chain_icon = {"Ethereum": "‚ü†", "Arbitrum": "üîµ", "Polygon": "üü£", "Base": "üî∑", "Optimism": "üî¥", "Solana": "üåû"}.get(chain, "üîó")
                # Format: SYMBOL (ICON Chain): AMOUNT - VALUE (PERCENT)
                if is_negative_token:
                    print(f"  {symbol} ({chain_icon} {chain}): {amount_str} - {format_currency(value)}")
                else:
                    print(f"  {symbol} ({chain_icon} {chain}): {amount_str} - {theme.SUCCESS}{format_currency(value)}{theme.RESET} ({token_percentage:.1f}%)")
            else:
                # Multi-chain: print summary then each breakdown
                if is_negative_token:
                    print(f"  {symbol}: {amount_str} {symbol} - {format_currency(value)}")
                else:
                    print(f"  {symbol}: {amount_str} {symbol} - {theme.SUCCESS}{format_currency(value)}{theme.RESET} ({token_percentage:.1f}%)")
                # Aggregate per-symbol chain dust (<$1)
                chain_dust_total = 0.0
                for chain_key in chains_for_symbol:
                    # Skip minor chains (<$1) and accumulate dust
                    if nonstable_breakdown[chain_key] < 1:
                        chain_dust_total += nonstable_breakdown[chain_key]
                        continue
                    chain = nonstable_chains[chain_key]
                    chain_value = nonstable_breakdown[chain_key]
                    chain_percentage = (chain_value / value * 100) if value > 0 and not is_negative_token else 0
                    chain_icon = {"Ethereum": "‚ü†", "Arbitrum": "üîµ", "Polygon": "üü£", "Base": "üî∑", "Optimism": "üî¥", "Solana": "üåû"}.get(chain, "üîó")
                    amount_chain = nonstable_amounts_by_chain.get(chain_key, 0)
                    amount_chain_str = f"{amount_chain:,.6f}".rstrip('0').rstrip('.') if amount_chain < 1 else f"{amount_chain:,.4f}".rstrip('0').rstrip('.')
                    if is_negative_token:
                        print(f"    {chain_icon} {chain}: {theme.ACCENT}{amount_chain_str} {symbol}{theme.RESET} - {format_currency(chain_value)}")
                    else:
                        print(f"    {chain_icon} {chain}: {theme.ACCENT}{amount_chain_str} {symbol}{theme.RESET} - {theme.SUBTLE}{format_currency(chain_value)}{theme.RESET} ({chain_percentage:.1f}%)")
                # Print per-symbol chain dust if any
                if chain_dust_total > 0:
                    dust_pct = (chain_dust_total / value * 100) if value > 0 and not is_negative_token else 0
                    if is_negative_token:
                        print(f"    {theme.SUBTLE}Other chains: {format_currency(chain_dust_total)}{theme.RESET}")
                    else:
                        print(f"    {theme.SUBTLE}Other chains: {format_currency(chain_dust_total)} ({dust_pct:.1f}%){theme.RESET}")
        
        # Show dust tokens total if any
        if dust_tokens_total > 0:
            dust_percentage = (dust_tokens_total / percentage_base * 100) if percentage_base and dust_tokens_total > 0 else 0
            print(f"  {theme.SUBTLE}Dust tokens (<$5): {format_currency(dust_tokens_total)} ({dust_percentage:.1f}%){theme.RESET}")
        
        print(f"  {theme.ACCENT}Total Non-Stable: {format_currency(non_stable_total)}{theme.RESET}")
        # Add category-specific breakdown lines
        eth_total = symbol_totals.get('ETH', 0)
        print(f"  {theme.ACCENT}üíé ETH Exposure: {format_currency(eth_total)}{theme.RESET}")
        # Compute Other Crypto as total non-stable minus ETH exposure
        other_total = non_stable_total - eth_total
        print(f"  {theme.ACCENT}üìà Other Crypto: {format_currency(other_total)}{theme.RESET}")
        # --- Store for summary ---
        eth_total_for_summary = eth_total
        other_total_for_summary = other_total
    
    # SUMMARY STATISTICS (print after breakdown so we have the correct values)
    if show_summary:
        print(f"\n{theme.PRIMARY}üìä SUMMARY STATISTICS{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * 20}{theme.RESET}")
        # Prepare summary values with overrides
        summary_totals = category_totals.copy()
        if eth_total_for_summary is not None:
            summary_totals['eth_exposure'] = eth_total_for_summary
        if other_total_for_summary is not None:
            summary_totals['other_crypto'] = other_total_for_summary

        total_categorized = sum(summary_totals.values())
        if total_categorized > 0:
            for category, value in sorted(summary_totals.items(), key=lambda x: x[1], reverse=True):
                if value > 0:
                    percentage = (value / total_categorized * 100)
                    category_display = {
                        'stable': 'üîí Stablecoins',
                        'eth_exposure': 'üíé ETH Exposure', 
                        'eth_staking': 'ü•© ETH Staking',
                        'lp_token': 'üîÑ LP Tokens',
                        'other_crypto': 'üìà Other Crypto'
                    }.get(category, f"üìä {category.title()}")
                    print(f"  {category_display}: {format_currency(value)} ({percentage:.1f}%)")


def _display_complete_wallet_details(wallet_data: Dict[str, Any], address: str, portfolio_metrics: Dict[str, Any]):
    """Display complete token and protocol details for a wallet with navigation."""
    from utils.display_theme import theme
    from utils.helpers import format_currency
    from tabulate import tabulate
    import os
    import time
    from datetime import datetime
    from dateutil import tz
    from collections import defaultdict

    tokens = wallet_data.get('tokens', [])
    protocols = wallet_data.get('protocols', [])
    
    # Sort data once
    sorted_tokens = sorted(tokens, key=lambda t: t.get('usd_value', 0), reverse=True)
    sorted_protocols = sorted(protocols, key=lambda p: p.get('total_value', p.get('value', 0)), reverse=True)
    
    # Navigation state
    token_start = 0
    protocol_start = 0
    page_size = 10
    show_all = False
    wallet_breakdown_view = False  # New state for wallet breakdown view
    breakdown_mode = 'token'  # or 'protocol'
    proto_index = 0  # for protocol navigation
    proto_show_all = False  # toggle between paginated and all protocols view
    proto_group_mode = False  # False = list by protocol, True = group by token type (stable / non)
    
    while True:
        # 1. Clear screen for a fresh view
        os.system('clear' if os.name == 'posix' else 'cls')
        
        # 2. Display wallet header
        address_short = f"{address[:8]}...{address[-6:]}" if len(address) > 14 else address
        total_value = wallet_data.get('total_usd_value', wallet_data.get('total_balance', 0))
        
        print(f"\n{theme.PRIMARY}üîç COMPLETE WALLET DETAILS{theme.RESET}")
        print(f"{theme.SUBTLE}{'=' * 27}{theme.RESET}")
        print(f"Address: {theme.ACCENT}{address_short}{theme.RESET}")
        print(f"Total Value: {theme.SUCCESS}{format_currency(total_value)}{theme.RESET}")
        
        # --- Timestamp Analysis - Use portfolio_metrics timestamp for consistency ---
        # When viewing past analysis, we want to show the same timestamp as the overview
        # This ensures consistency between "Portfolio Overview ‚Ä¢ Saved 2025-06-10 12:11:41"
        # and "Analysis Time: 2025-06-10 12:11:41" in wallet details
        analysis_ts_str = portfolio_metrics.get("timestamp", wallet_data.get("timestamp", "N/A"))
        
        try:
            utc_dt = datetime.fromisoformat(analysis_ts_str.replace("Z", "+00:00"))
            local_tz = tz.tzlocal()
            local_dt = utc_dt.astimezone(local_tz)
            timezone_name = local_dt.tzname()
            display_ts = local_dt.strftime(f'%Y-%m-%d %H:%M:%S ({timezone_name})')
            print(f"Analysis Time: {theme.SUBTLE}{display_ts}{theme.RESET}")
        except (ValueError, TypeError, ImportError):
            display_ts = analysis_ts_str # Fallback to raw string
            print(f"Analysis Time: {theme.SUBTLE}{display_ts}{theme.RESET}")
        
        # Wallet breakdown views
        if wallet_breakdown_view:
            if breakdown_mode == 'token':
                _display_wallet_summary_stats(tokens, protocols, show_summary=False)
                print(f"\n{theme.PRIMARY}NAVIGATION:{theme.RESET} (p)rotocol breakdown | (b)ack | (q)uit")
            else:  # protocol mode
                # Handle grouped-by-token view first
                if proto_group_mode:
                    # --- Group protocol positions by token and chain ---
                    stable_bases = {'USDC', 'USDT', 'DAI', 'FDUSD', 'USDE', 'FRAX', 'TUSD', 'PYUSD', 'GUSD', 'PAX', 'BUSD', 'GHO', 'CRVUSD'}
                    stable_patterns = ['USD']
                    chain_icons = {"Ethereum": "‚ü†", "Arbitrum": "üîµ", "Polygon": "üü£", "Base": "üî∑", "Optimism": "üî¥", "Solana": "üåû"}

                    def _normalize_symbol(symbol: str) -> str:
                        return (symbol or "").replace(" ", "").upper()

                    # Helper to detect if a single token is a stablecoin
                    def _is_base_stable(token: str) -> bool:
                        clean = _normalize_symbol(token)
                        if not clean:
                            return False
                        if clean in stable_bases:
                            return True
                        for pat in stable_patterns:
                            if pat in clean:
                                return True
                        return False

                    # Helper to detect stablecoins (supports composite symbols)
                    def is_stable(symbol: str) -> bool:
                        clean = _normalize_symbol(symbol)
                        if '+' in clean:
                            parts = [part for part in clean.split('+') if part]
                            return bool(parts) and all(_is_base_stable(part) for part in parts)
                        if '/' in clean or '-' in clean:
                            return False
                        return _is_base_stable(clean)

                    # Helper to detect if a pool is stable (all parts stable)
                    def is_pool_stable(symbol: str) -> bool:
                        clean = _normalize_symbol(symbol)
                        if '+' in clean:
                            parts = [part for part in clean.split('+') if part]
                            return bool(parts) and all(_is_base_stable(part) for part in parts)
                        if '/' in clean or '-' in clean:
                            return False
                        return _is_base_stable(clean)

                    # Aggregate by (symbol, chain)
                    token_protocols = defaultdict(lambda: defaultdict(set))  # symbol -> chain -> set of (protocol, type)
                    token_protocols_usd = defaultdict(lambda: defaultdict(lambda: defaultdict(float)))  # symbol -> chain -> (protocol, type) -> usd
                    token_chain_totals = defaultdict(lambda: {"usd": 0, "amt": 0})
                    token_totals = defaultdict(lambda: {"usd": 0, "amt": 0, "chains": defaultdict(lambda: {"usd": 0, "amt": 0})})

                    for proto in protocols:
                        chain = proto.get('chain', 'unknown').capitalize()
                        proto_name = proto.get('name', 'Unknown')
                        for pos in proto.get('positions', []):
                            raw = (pos.get('asset') or pos.get('label') or '').strip()
                            parts = raw.split()
                            if len(parts) > 1 and any(ch.isdigit() for ch in parts[0]):
                                symbol = parts[-1].upper()
                            else:
                                symbol = raw.upper()
                            amt = pos.get('amount') or pos.get('qty') or pos.get('balance') or 0
                            try:
                                amt = float(amt)
                            except Exception:
                                amt = 0
                            usd = pos.get('usd_value', pos.get('value', 0)) or 0
                            try:
                                usd = float(usd)
                            except Exception:
                                usd = 0
                            ptype = pos.get('header_type', '-') or '-'
                            is_borrowed = str(ptype).lower() == 'borrowed'
                            token_protocols[symbol][chain].add((proto_name, ptype))
                            # If symbol contains '+', check if any part is non-stable; if so, treat as non-stable
                            if '+' in symbol:
                                parts = symbol.split('+')
                                if any(not is_stable(part.strip()) for part in parts):
                                    # Treat as non-stable
                                    target_totals = token_totals
                                else:
                                    # All parts are stable, treat as stable
                                    target_totals = token_totals
                            else:
                                target_totals = token_totals
                            if is_borrowed:
                                token_protocols_usd[symbol][chain][(proto_name, ptype)] -= usd
                                target_totals[symbol]["usd"] -= usd
                                target_totals[symbol]["amt"] -= amt
                                target_totals[symbol]["chains"][chain]["usd"] -= usd
                                target_totals[symbol]["chains"][chain]["amt"] -= amt
                            else:
                                token_protocols_usd[symbol][chain][(proto_name, ptype)] += usd
                                target_totals[symbol]["usd"] += usd
                                target_totals[symbol]["amt"] += amt
                                target_totals[symbol]["chains"][chain]["usd"] += usd
                                target_totals[symbol]["chains"][chain]["amt"] += amt

                    # Split into stables and non-stables
                    stables = {k: v for k, v in token_totals.items() if is_pool_stable(k)}
                    nonstables = {k: v for k, v in token_totals.items() if not is_pool_stable(k)}

                    # Only show grouped breakdowns if proto_group_mode is True
                    if proto_group_mode:
                        while True:
                            os.system('clear' if os.name == 'posix' else 'cls')
                            # Print Stablecoin Breakdown
                            print(f"\n{theme.INFO}Stablecoin Breakdown:{theme.RESET}")
                            stables_filtered = {k: v for k, v in stables.items() if isinstance(v, dict) and isinstance(v.get('usd', None), (int, float))}
                            # Calculate total excluding negative values for percentage calculation
                            total_stables_positive = sum(v["usd"] for v in stables_filtered.values() if v["usd"] > 0)
                            total_stables = sum(v["usd"] for v in stables_filtered.values())
                            dust_stables = 0
                            for symbol, data in sorted(stables_filtered.items(), key=lambda x: -abs(x[1]["usd"]) if isinstance(x[1], dict) and isinstance(x[1].get("usd"), (int, float)) else 0):
                                if not isinstance(data, dict):
                                    continue
                                if abs(data["usd"]) < 10:
                                    dust_stables += data["usd"]
                                    continue
                                
                                # Check if token has negative total value
                                is_negative_token = data["usd"] < 0
                                
                                pct = (data["usd"] / total_stables_positive * 100) if total_stables_positive and not is_negative_token else 0
                                chains_for_symbol = list(data["chains"].keys()) if isinstance(data["chains"], dict) else []
                                if len(chains_for_symbol) == 1:
                                    chain = chains_for_symbol[0]
                                    icon = chain_icons.get(chain, "üîó")
                                    protos_types_usd = token_protocols_usd[symbol][chain]
                                    if len(protos_types_usd) == 1:
                                        (pname, ptype), p_usd = next(iter(protos_types_usd.items()))
                                        if is_negative_token:
                                            print(f"  {symbol} ({icon} {chain}): {format_currency(data['usd'])} \u2190 {pname} [{ptype}]")
                                        else:
                                            print(f"  {symbol} ({icon} {chain}): {format_currency(data['usd'])} ({pct:.1f}%) \u2190 {pname} [{ptype}]")
                                    else:
                                        if is_negative_token:
                                            print(f"  {symbol} ({icon} {chain}): {format_currency(data['usd'])}")
                                        else:
                                            print(f"  {symbol} ({icon} {chain}): {format_currency(data['usd'])} ({pct:.1f}%)")
                                        for (pname, ptype), p_usd in sorted(protos_types_usd.items(), key=lambda x: -x[1]):
                                            has_negative_protocols = any(p < 0 for p in protos_types_usd.values())
                                            if is_negative_token or has_negative_protocols:
                                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                                            else:
                                                p_pct = (p_usd / data['usd'] * 100) if data['usd'] else 0
                                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                                else:
                                    if is_negative_token:
                                        print(f"  {symbol}: {format_currency(data['usd'])}")
                                    else:
                                        print(f"  {symbol}: {format_currency(data['usd'])} ({pct:.1f}%)")
                                    if isinstance(data["chains"], dict):
                                        for chain, cdata in sorted(data["chains"].items(), key=lambda x: -x[1]["usd"] if isinstance(x[1], dict) else 0):
                                            if not isinstance(cdata, dict):
                                                continue
                                            cpct = (cdata["usd"] / data["usd"] * 100) if data["usd"] and not is_negative_token else 0
                                            icon = chain_icons.get(chain, "üîó")
                                            protos_types_usd = token_protocols_usd[symbol][chain]
                                            if len(protos_types_usd) == 1:
                                                (pname, ptype), p_usd = next(iter(protos_types_usd.items()))
                                                if is_negative_token:
                                                    print(f"    {icon} {chain}: {format_currency(cdata['usd'])}  \u2190 {pname} [{ptype}]")
                                                else:
                                                    print(f"    {icon} {chain}: {format_currency(cdata['usd'])} ({cpct:.1f}%)  \u2190 {pname} [{ptype}]")
                                            else:
                                                if is_negative_token:
                                                    print(f"    {icon} {chain}: {format_currency(cdata['usd'])}")
                                                else:
                                                    print(f"    {icon} {chain}: {format_currency(cdata['usd'])} ({cpct:.1f}%)")
                                                for (pname, ptype), p_usd in sorted(protos_types_usd.items(), key=lambda x: -x[1]):
                                                    has_negative_protocols = any(p < 0 for p in protos_types_usd.values())
                                                    if is_negative_token or has_negative_protocols:
                                                        print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                                                    else:
                                                        p_pct = (p_usd / data['usd'] * 100) if data['usd'] else 0
                                                        print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                            if dust_stables > 0:
                                dust_percentage = (dust_stables / total_stables_positive * 100) if total_stables_positive and dust_stables > 0 else 0
                                print(f"  {theme.SUBTLE}Dust stables (<$10): {format_currency(dust_stables)} ({dust_percentage:.1f}%){theme.RESET}")
                            print(f"  {theme.ACCENT}Total Stables: {format_currency(total_stables)}{theme.RESET}")

                            # Print Non-Stable Token Breakdown
                            print(f"\n{theme.INFO}Non-Stable Token Breakdown:{theme.RESET}")
                            nonstables_filtered = {k: v for k, v in nonstables.items() if isinstance(v, dict) and isinstance(v.get('usd', None), (int, float))}
                            
                            # Calculate total excluding negative values for percentage calculation
                            total_nonstables_positive = sum(v["usd"] for v in nonstables_filtered.values() if v["usd"] > 0)
                            total_nonstables = sum(v["usd"] for v in nonstables_filtered.values())
                            
                            # Fix percentage calculation: Use positive-only base when there are negative values
                            # This ensures positive token percentages add up to 100% instead of over 100%
                            has_negative_values = any(v["usd"] < 0 for v in nonstables_filtered.values())
                            if has_negative_values:
                                # When there are negative values, use only positive values for percentage base
                                percentage_base = total_nonstables_positive
                            else:
                                # When all values are positive, use full total (original behavior)
                                percentage_base = total_nonstables if total_nonstables > 0 else total_nonstables_positive
                            dust_nonstables = 0
                            for symbol, data in sorted(nonstables_filtered.items(), key=lambda x: (x[1]["usd"] < 0, -abs(x[1]["usd"])) if isinstance(x[1], dict) and isinstance(x[1].get("usd"), (int, float)) else (True, 0)):
                                if not isinstance(data, dict):
                                    continue
                                if abs(data["usd"]) < 5:  # Use absolute value for dust threshold
                                    dust_nonstables += data["usd"]
                                    continue
                                
                                # Check if token has negative total value
                                is_negative_token = data["usd"] < 0
                                
                                # Use positive total for percentage calculation
                                pct = round(data["usd"] / percentage_base * 100, 1) if percentage_base and not is_negative_token else 0
                                amt = data["amt"]
                                amt_str = f"{amt:.6f}".rstrip('0').rstrip('.') if isinstance(amt, (int, float)) and amt < 1 else f"{amt:,.4f}".rstrip('0').rstrip('.')
                                chains_for_symbol = list(data["chains"].keys()) if isinstance(data["chains"], dict) else []
                                if len(chains_for_symbol) == 1:
                                    chain = chains_for_symbol[0]
                                    icon = chain_icons.get(chain, "üîó")
                                    protos_types_usd = token_protocols_usd[symbol][chain]
                                    if len(protos_types_usd) == 1:
                                        (pname, ptype), p_usd = next(iter(protos_types_usd.items()))
                                        if is_negative_token:
                                            print(f"  {symbol} ({icon} {chain}): {amt_str} - {format_currency(data['usd'])} \u2190 {pname} [{ptype}]")
                                        else:
                                            print(f"  {symbol} ({icon} {chain}): {amt_str} - {format_currency(data['usd'])} ({pct:.1f}%) \u2190 {pname} [{ptype}]")
                                    else:
                                        if is_negative_token:
                                            print(f"  {symbol} ({icon} {chain}): {amt_str} - {format_currency(data['usd'])}")
                                        else:
                                            print(f"  {symbol} ({icon} {chain}): {amt_str} - {format_currency(data['usd'])} ({pct:.1f}%)")
                                        for (pname, ptype), p_usd in sorted(protos_types_usd.items(), key=lambda x: -x[1]):
                                            # Check if this token has any negative protocol positions
                                            has_negative_protocols = any(p < 0 for p in protos_types_usd.values())
                                            if is_negative_token or has_negative_protocols:
                                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                                            else:
                                                p_pct = (p_usd / data['usd'] * 100) if data['usd'] else 0
                                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                                else:
                                    if is_negative_token:
                                        print(f"  {symbol}: {amt_str} - {format_currency(data['usd'])}")
                                    else:
                                        print(f"  {symbol}: {amt_str} - {format_currency(data['usd'])} ({pct:.1f}%)")
                                    if isinstance(data["chains"], dict):
                                        for chain, cdata in sorted(data["chains"].items(), key=lambda x: -x[1]["usd"] if isinstance(x[1], dict) else 0):
                                            if not isinstance(cdata, dict):
                                                continue
                                            if cdata["usd"] == 0:
                                                continue
                                            cpct = (cdata["usd"] / data["usd"] * 100) if data["usd"] and not is_negative_token else 0
                                            icon = chain_icons.get(chain, "üîó")
                                            camt = cdata["amt"]
                                            camt_str = f"{camt:.6f}".rstrip('0').rstrip('.') if camt < 1 else f"{camt:,.4f}".rstrip('0').rstrip('.')
                                            protos_types_usd = token_protocols_usd[symbol][chain]
                                            if len(protos_types_usd) == 1:
                                                (pname, ptype), p_usd = next(iter(protos_types_usd.items()))
                                                if is_negative_token:
                                                    print(f"    {icon} {chain}: {camt_str} - {format_currency(cdata['usd'])}  \u2190 {pname} [{ptype}]")
                                                else:
                                                    print(f"    {icon} {chain}: {camt_str} - {format_currency(cdata['usd'])} ({cpct:.1f}%)  \u2190 {pname} [{ptype}]")
                                            else:
                                                chain_has_negative = any(p < 0 for p in protos_types_usd.values())
                                                if is_negative_token or chain_has_negative:
                                                    print(f"    {icon} {chain}: {camt_str} - {format_currency(cdata['usd'])}")
                                                else:
                                                    print(f"    {icon} {chain}: {camt_str} - {format_currency(cdata['usd'])} ({cpct:.1f}%)")
                                                for (pname, ptype), p_usd in sorted(protos_types_usd.items(), key=lambda x: -x[1]):
                                                    if is_negative_token or chain_has_negative:
                                                        print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                                                    else:
                                                        p_pct = (p_usd / data['usd'] * 100) if data['usd'] else 0
                                                        print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                            if dust_nonstables > 0:
                                dust_percentage = (dust_nonstables / percentage_base * 100) if percentage_base and dust_nonstables > 0 else 0
                                print(f"  Dust tokens (<$5): {format_currency(dust_nonstables)} ({dust_percentage:.1f}%)")
                            print(f"  Total Non-Stable: {format_currency(total_nonstables)}")

                            print(f"\n{theme.PRIMARY}NAVIGATION:{theme.RESET} (g) protocol list | (b)ack | (q)uit")
                            try:
                                choice = input(f"\n{theme.PRIMARY}Enter command: {theme.RESET}").strip().lower()
                                if choice == 'g':
                                    proto_group_mode = False
                                    break
                                elif choice == 'b':
                                    wallet_breakdown_view = False
                                    breakdown_mode = 'token'
                                    proto_index = 0
                                    break
                                elif choice == 'q':
                                    return
                                else:
                                    print(f"{theme.ERROR}‚ùå Invalid command '{choice}'{theme.RESET}")
                                    time.sleep(1.5)
                            except (ValueError, KeyboardInterrupt):
                                break
                            except Exception as e:
                                print(f"{theme.ERROR}‚ùå An error occurred: {str(e)}{theme.RESET}")
                                time.sleep(2)
                        continue  # restart main loop

                # Detailed protocol breakdown ‚Äì paginated or all-view
                from tabulate import tabulate as _tab

                print(f"\n{theme.INFO}Protocol Breakdown:{theme.RESET}")

                dust_total = 0.0
                total_proto_val = 0.0

                sorted_protos = sorted(
                    protocols, key=lambda p: p.get('total_value', p.get('value', 0)), reverse=True
                )

                # Pre-compute aggregate totals (exact values) for persistence across pages
                dust_total_all = 0.0
                total_proto_val_all = 0.0

                # Helper to compute exact value of a protocol
                def _protocol_exact_val(proto_dict):
                    positions_ = proto_dict.get('positions', [])
                    if not positions_:
                        return proto_dict.get('total_value', proto_dict.get('value', 0))
                    total_ = 0.0
                    for _pos in positions_:
                        v_ = _pos.get('usd_value', _pos.get('value', 0)) or 0
                        if str(_pos.get('header_type', '')).lower() == 'borrowed':
                            total_ -= v_
                        else:
                            total_ += v_
                    return total_

                for _proto in sorted_protos:
                    val = _protocol_exact_val(_proto)
                    if val < 10:
                        dust_total_all += val
                    else:
                        total_proto_val_all += val

                # Build list of protocols that will actually be shown (value ‚â• $10)
                display_protos = [p for p in sorted_protos if _protocol_exact_val(p) >= 10]

                # Guard against empty list
                if not display_protos:
                    print(f"{theme.SUBTLE}No protocols to display{theme.RESET}")
                else:
                    # Determine which protocols to render this cycle
                    protos_to_show = (
                        display_protos                              # all protocols on one page
                        if proto_show_all
                        else display_protos[proto_index : proto_index + 5]
                    )

                    for proto in protos_to_show:
                        # Compute exact value by summing positions (borrowed negative)
                        positions = proto.get('positions', [])
                        if positions:
                            pos_total = 0.0
                            for pos in positions:
                                v = pos.get('usd_value', pos.get('value', 0)) or 0
                                if str(pos.get('header_type', '')).lower() == 'borrowed':
                                    pos_total -= v
                                else:
                                    pos_total += v
                            exact_val = pos_total
                        else:
                            exact_val = proto.get('total_value', proto.get('value', 0))

                        if exact_val < 10:
                            # Skip displaying dust protocol (aggregated later)
                            continue
                        # Display protocol and accumulate to page-level total (not strictly needed)

                        name = proto.get('name', 'Unknown')
                        chain = proto.get('chain', 'unknown').capitalize()

                        print(
                            f"\n{theme.ACCENT}{name}{theme.RESET} ‚Ä¢ {chain} ‚Äî {theme.PRIMARY}{format_currency(exact_val)}{theme.RESET}"
                        )

                        if positions:
                            rows = []
                            for pos in positions:
                                label = pos.get('label', '')
                                asset = pos.get('asset', '')
                                ptype = pos.get('header_type', '') or '-'
                                usd_val = pos.get('usd_value', pos.get('value', 0))
                                rows.append([label, asset, ptype, format_currency(usd_val)])
                            print(_tab(rows, headers=["Label", "Asset / Amount", "Type", "USD Value"], tablefmt="simple"))
                        else:
                            print(f"{theme.SUBTLE}No positions found{theme.RESET}")

                    # When showing single protocol, accumulate dust/total later outside loop

                # Show aggregated dust protocols and totals
                if dust_total_all > 0:
                    print(f"\n  {theme.SUBTLE}Others (<$10): {format_currency(dust_total_all)}{theme.RESET}")

                print(f"  {theme.ACCENT}Total Protocols: {format_currency(total_proto_val_all + dust_total_all)}{theme.RESET}")

                # ------------------- Navigation footer -------------------
                if proto_group_mode:
                    # In grouped view we only allow return to list
                    nav_line = ""
                    toggle_label = "(g) protocol list"
                else:
                    if proto_show_all:
                        nav_line = ""  # no prev/next in all view
                        toggle_label = "(p)aginated view | (g)roup by type"
                    else:
                        nav_parts = []
                        if proto_index > 0:
                            nav_parts.append("(p)rev")
                        if proto_index + 5 < len(display_protos):
                            nav_parts.append("(n)ext")
                        nav_line = " / ".join(nav_parts)
                        toggle_label = "(a)ll view | (g)roup by type"

                sep = " | " if nav_line else ""
                print(
                    f"\n{theme.PRIMARY}NAVIGATION:{theme.RESET} {nav_line}{sep}{toggle_label} | (t)oken breakdown | (b)ack | (q)uit"
                )

            try:
                choice = input(f"\n{theme.PRIMARY}Enter command: {theme.RESET}").strip().lower()
                if choice == 'b':
                    # exit wallet breakdown view entirely
                    wallet_breakdown_view = False
                    breakdown_mode = 'token'
                    proto_index = 0  # reset to first protocol
                elif choice == 'q':
                    break
                elif choice == 'p' and breakdown_mode == 'token':
                    breakdown_mode = 'protocol'
                    proto_index = 0  # reset to first protocol
                elif choice == 't' and breakdown_mode == 'protocol':
                    breakdown_mode = 'token'
                # Protocol navigation (paginated mode only)
                elif breakdown_mode == 'protocol' and not proto_group_mode and not proto_show_all and choice == 'n':
                    proto_index = proto_index + 5
                    if proto_index >= len(display_protos):
                        proto_index = 0  # wrap to beginning
                elif breakdown_mode == 'protocol' and not proto_group_mode and not proto_show_all and choice == 'p':
                    if proto_index == 0:
                        # wrap to last full page
                        proto_index = max(0, len(display_protos) - (len(display_protos) % 5 or 5))
                    else:
                        proto_index -= 5
                elif breakdown_mode == 'protocol' and proto_show_all and choice == 'p':
                    # switch back to paginated view
                    proto_show_all = False
                    proto_index = 0
                elif breakdown_mode == 'protocol' and not proto_group_mode and choice == 'a':
                    proto_show_all = True
                    proto_index = 0
                elif breakdown_mode == 'protocol' and not proto_group_mode and choice == 'g':
                    proto_group_mode = True
                elif choice:
                    print(f"{theme.ERROR}‚ùå Invalid command '{choice}'{theme.RESET}")
                    time.sleep(1.5)
            except (ValueError, KeyboardInterrupt):
                break
            except Exception as e:
                print(f"{theme.ERROR}‚ùå An error occurred: {str(e)}{theme.RESET}")
                time.sleep(2)
            continue  # restart loop
        
        # 3. Display tokens section
        if sorted_tokens:
            if show_all:
                showing_tokens = sorted_tokens
                print(f"\n{theme.PRIMARY}ü™ô TOKENS ({len(sorted_tokens)} total - All){theme.RESET}")
            else:
                token_end = min(token_start + page_size, len(sorted_tokens))
                showing_tokens = sorted_tokens[token_start:token_end]
                print(f"\n{theme.PRIMARY}ü™ô TOKENS (showing {token_start+1}-{token_end} of {len(sorted_tokens)}){theme.RESET}")

            token_table = []
            start_index = 1 if show_all else token_start + 1
            for i, token in enumerate(showing_tokens, start=start_index):
                symbol = token.get('symbol', 'Unknown')
                amount = token.get('amount', 0)
                usd_value = token.get('usd_value', 0)
                category = token.get('category', 'other_crypto')
                
                chain = token.get('chain', 'n/a').capitalize()
                chain_icon = {
                    "Ethereum": "‚ü†", 
                    "Arbitrum": "üîµ", 
                    "Polygon": "üü£", 
                    "Base": "üî∑", 
                    "Optimism": "üî¥", 
                    "Sonic": "‚ö°",
                    "Soneium": "üü°",
                    "Linea": "üü¢",
                    "Ink": "üñãÔ∏è",
                    "Lisk": "üî∂",
                    "Abstract": "üé≠",
                    "Gravity": "üåç",
                    "Itze": "‚≠ê",
                    "Rsk": "üü†",
                    "Bsc": "üü®",
                    "Xlayer": "‚ùå",
                    "Mantle": "üß•",
                    "Avalanche": "üèîÔ∏è",
                    "Fantom": "üëª",
                    "Celo": "üíö",
                    "Near": "üî∫",
                    "Solana": "üåû",
                    "Unichain": "ü¶Ñ",
                    "Era": "‚ö°",
                    "Rari": "üíé",
                    "Frax": "‚ùÑÔ∏è",
                    "Bera": "üêª",
                    "Lens": "üì∑",
                    "Metis": "üî¥",
                    "Pze": "üî∑",
                    "Fuse": "üî•",
                    "Dbk": "üè¶",
                    "Blast": "üí•",
                    "Taiko": "ü•Å",
                    "Xdai": "üí∞",
                    "Core": "‚ö´",
                    "Dfk": "üè∞",
                    "Zora": "üé®",
                    "Mobm": "üì±",
                    "Scrl": "üìú",
                    "Cyber": "ü§ñ",
                    "Bob": "üë§",
                    "Manta": "üêô",
                    "Karak": "üèîÔ∏è",
                    "Mode": "üéÆ",
                    "Tlos": "üî∫",
                    "Canto": "üéµ",
                    "Zeta": "‚ö°",
                    "Nova": "üí´",
                    "Wemix": "üéÆ",
                    "Sei": "üåä",
                    "Movr": "üåô",
                    "Kava": "‚òï",
                    "Cfx": "üåä",
                    "Boba": "üßã",
                    "Bb": "üîµ",
                    "Astar": "‚≠ê"
                }.get(chain, "üîó")

                cat_icon = {"stable": "üîí", "eth_exposure": "üíé", "eth_staking": "ü•©", "lp_token": "üîÑ"}.get(category, "üìà")
                amount_str = f"{amount:,.6f}".rstrip('0').rstrip('.') if amount >= 1 else f"{amount:.8f}".rstrip('0').rstrip('.')
                
                token_table.append([
                    f"{theme.SUBTLE}{i}{theme.RESET}", 
                    f"{cat_icon} {theme.ACCENT}{symbol}{theme.RESET}", 
                    f"{theme.SUBTLE}{amount_str}{theme.RESET}", 
                    f"{theme.PRIMARY}{format_currency(usd_value)}{theme.RESET}",
                    f"{chain_icon} {theme.SUBTLE}{chain}{theme.RESET}",
                    f"{theme.SUBTLE}{category}{theme.RESET}"
                ])
            
            print(tabulate(token_table, headers=["#", "Token", "Amount", "USD Value", "Chain", "Category"], tablefmt="simple"))
        else:
            print(f"\n{theme.SUBTLE}No tokens found{theme.RESET}")
        
        # 4. Display protocols section
        if sorted_protocols:
            if show_all:
                showing_protocols = sorted_protocols
                print(f"\n{theme.PRIMARY}üèõÔ∏è PROTOCOLS ({len(sorted_protocols)} total - All){theme.RESET}")
            else:
                protocol_end = min(protocol_start + page_size, len(sorted_protocols))
                showing_protocols = sorted_protocols[protocol_start:protocol_end]
                print(f"\n{theme.PRIMARY}üèõÔ∏è PROTOCOLS (showing {protocol_start+1}-{protocol_end} of {len(sorted_protocols)}){theme.RESET}")

            protocol_table = []
            start_index = 1 if show_all else protocol_start + 1
            for i, protocol in enumerate(showing_protocols, start=start_index):
                name = protocol.get('name', 'Unknown')
                total_value_proto = protocol.get('total_value', protocol.get('value', 0))
                chain = protocol.get('chain', 'ethereum')
                chain_icon = {"ethereum": "‚ü†", "arbitrum": "üîµ", "polygon": "üü£", "base": "üî∑", "optimism": "üî¥"}.get(chain.lower(), "üîó")
                protocol_table.append([f"{theme.SUBTLE}{i}{theme.RESET}", f"{theme.ACCENT}{name}{theme.RESET}", f"{theme.PRIMARY}{format_currency(total_value_proto)}{theme.RESET}", f"{chain_icon} {theme.SUBTLE}{chain.capitalize()}{theme.RESET}"])

            print(tabulate(protocol_table, headers=["#", "Protocol", "USD Value", "Chain"], tablefmt="simple"))
        else:
            print(f"\n{theme.SUBTLE}No protocols found{theme.RESET}")
        
        # 5. Intuitive navigation menu
        nav_hints = []
        valid_commands = {}
        
        if show_all:
            nav_hints.append("(p)aginated view")
            valid_commands['p'] = 'toggle_view'
        else:
            # Token navigation
            if len(sorted_tokens) > page_size:
                token_nav_parts = []
                if token_start > 0:
                    token_nav_parts.append("(p)rev")
                    valid_commands['tp'] = 'prev_tokens'
                if token_start + page_size < len(sorted_tokens):
                    token_nav_parts.append("(n)ext")
                    valid_commands['tn'] = 'next_tokens'
                if token_nav_parts:
                    nav_hints.append(f"[T]okens: {'/'.join(token_nav_parts)}")

            # Protocol navigation
            if len(sorted_protocols) > page_size:
                protocol_nav_parts = []
                if protocol_start > 0:
                    protocol_nav_parts.append("(p)rev")
                    valid_commands['pp'] = 'prev_protocols'
                if protocol_start + page_size < len(sorted_protocols):
                    protocol_nav_parts.append("(n)ext")
                    valid_commands['pn'] = 'next_protocols'
                if protocol_nav_parts:
                    nav_hints.append(f"[P]rotocols: {'/'.join(protocol_nav_parts)}")
            
            # Reset command for pagination
            if token_start > 0 or protocol_start > 0:
                nav_hints.append("(r)eset pages")
                valid_commands['r'] = 'reset_pages'

            nav_hints.append("(a)ll view")
            valid_commands['a'] = 'toggle_view'

        # General commands
        nav_hints.append("(s)ummary")
        valid_commands['s'] = 'summary'
        nav_hints.append("(w)allet breakdown")
        valid_commands['w'] = 'wallet_breakdown'
        nav_hints.append("(q)uit")
        valid_commands['q'] = 'return'

        print(f"\n{theme.PRIMARY}NAVIGATION:{theme.RESET} {' | '.join(nav_hints)}")
        
        # 6. Get and process user choice
        try:
            choice = input(f"\n{theme.PRIMARY}Enter command: {theme.RESET}").strip().lower()
            
            if choice in valid_commands:
                action = valid_commands[choice]
                
                if action == "prev_tokens":
                    token_start = max(0, token_start - page_size)
                elif action == "next_tokens":
                    token_start += page_size
                elif action == "prev_protocols":
                    protocol_start = max(0, protocol_start - page_size)
                elif action == "next_protocols":
                    protocol_start += page_size
                elif action == "reset_pages":
                    token_start = 0
                    protocol_start = 0
                elif action == "toggle_view":
                    show_all = not show_all
                    token_start = 0
                    protocol_start = 0
                elif action == "summary":
                    # Combined summary: token breakdown and protocol (grouped by token) breakdown
                    os.system('clear' if os.name == 'posix' else 'cls')
                    print(f"\n{theme.PRIMARY}üîç WALLET SUMMARY BREAKDOWN{theme.RESET}")
                    print(f"{theme.SUBTLE}{'=' * 27}{theme.RESET}")
                    print(f"Address: {theme.ACCENT}{address_short}{theme.RESET}")
                    print(f"Total Value: {theme.SUCCESS}{format_currency(total_value)}{theme.RESET}")
                    analysis_ts_str = portfolio_metrics.get("timestamp", wallet_data.get("timestamp", "N/A"))
                    try:
                        utc_dt = datetime.fromisoformat(analysis_ts_str.replace("Z", "+00:00"))
                        local_tz = tz.tzlocal()
                        local_dt = utc_dt.astimezone(local_tz)
                        timezone_name = local_dt.tzname()
                        display_ts = local_dt.strftime(f'%Y-%m-%d %H:%M:%S ({timezone_name})')
                        print(f"Analysis Time: {theme.SUBTLE}{display_ts}{theme.RESET}")
                    except (ValueError, TypeError, ImportError):
                        display_ts = analysis_ts_str # Fallback to raw string
                        print(f"Analysis Time: {theme.SUBTLE}{display_ts}{theme.RESET}")
                    
                    # Display merged stable breakdown (combines token and protocol data)
                    stable_total = _display_merged_stable_breakdown(tokens, protocols)
                    
                    # Display merged non-stable token breakdown (combines token and protocol data)
                    _display_merged_nonstable_breakdown(tokens, protocols, stable_total=stable_total)
                    
                    input(f"\n{theme.SUBTLE}Press Enter to return...{theme.RESET}")
                elif action == "wallet_breakdown":
                    wallet_breakdown_view = True
                    breakdown_mode = 'token'
                elif action == "return":
                    break
            elif choice: # Non-empty but invalid
                print(f"{theme.ERROR}‚ùå Invalid command '{choice}'{theme.RESET}")
                time.sleep(1.5)

        except (ValueError, KeyboardInterrupt):
            break
        except Exception as e:
            print(f"{theme.ERROR}‚ùå An error occurred: {str(e)}{theme.RESET}")
            time.sleep(2)
    
    print(f"\n{theme.SUBTLE}Returning to wallet selection...{theme.RESET}")

    # Show totals
    total_token_value = sum(t.get('usd_value', 0) for t in tokens)
    total_protocol_value = sum(p.get('total_value', p.get('value', 0)) for p in protocols)

    print(f"\n{theme.SUCCESS}Total Token Value: {format_currency(total_token_value)}{theme.RESET}")
    print(f"{theme.SUCCESS}Total Protocol Value: {format_currency(total_protocol_value)}{theme.RESET}")


def display_hyperliquid_positions(portfolio_metrics: Dict[str, Any]):
    """Enhanced Hyperliquid positions display with improved formatting and theming."""
    print_header("Hyperliquid Positions")

    # Extract wallet platform data from portfolio metrics
    wallet_platform_data = portfolio_metrics.get("wallet_platform_data_raw", [])

    hyperliquid_data = [
        info for info in wallet_platform_data if info.get("platform") == "hyperliquid"
    ]
    if not hyperliquid_data:
        print(f"{theme.SUBTLE}No Hyperliquid accounts tracked or no data available.{theme.RESET}")
        return

    total_hyperliquid_balance = sum(info.get("total_balance", 0.0) for info in hyperliquid_data)

    # Enhanced summary with trading icon
    print(f"\n{theme.PRIMARY}‚ö° HYPERLIQUID SUMMARY{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 23}{theme.RESET}")
    print(f"Total Account Value: {theme.SUCCESS}{format_currency(total_hyperliquid_balance)}{theme.RESET}")
    print(f"Active Accounts:     {theme.ACCENT}{len(hyperliquid_data)}{theme.RESET}")

    for i, account in enumerate(hyperliquid_data):
        account_balance = account.get("total_balance", 0.0)
        address = account.get("address", "N/A")
        address_short = address[:8] + "..." + address[-6:] if address != "N/A" else "N/A"

        print(f"\n{theme.PRIMARY}üìä ACCOUNT {i+1}: {theme.ACCENT}{address_short}{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * (17 + len(address_short))}{theme.RESET}")
        print(f"Account Value: {theme.SUCCESS}{format_currency(account_balance)}{theme.RESET}")

        positions = account.get("open_positions", [])
        if not positions:
            print(f"\n{theme.SUBTLE}No open positions{theme.RESET}")
            continue

        print(f"\n{theme.SUBTLE}Open Positions{theme.RESET}")
        
        headers = [
            f"{theme.PRIMARY}Asset{theme.RESET}",
            f"{theme.PRIMARY}Position{theme.RESET}",
            f"{theme.PRIMARY}Entry Price{theme.RESET}",
            f"{theme.PRIMARY}Liq. Price{theme.RESET}",
            f"{theme.PRIMARY}Leverage{theme.RESET}",
            f"{theme.PRIMARY}Unrealized PNL{theme.RESET}",
        ]
        table_data = []

        for p in positions:
            size = p.get("size", 0.0)
            
            # Enhanced position direction display
            if size > 0:
                direction = f"{theme.SUCCESS}üìà Long{theme.RESET}"
                position_display = f"{abs(size):.4f} ({direction})"
            elif size < 0:
                direction = f"{theme.ERROR}üìâ Short{theme.RESET}"
                position_display = f"{abs(size):.4f} ({direction})"
            else:
                direction = f"{theme.SUBTLE}‚ûñ Flat{theme.RESET}"
                position_display = f"{abs(size):.4f} ({direction})"

            # Enhanced PNL formatting
            pnl = p.get("unrealized_pnl", 0)
            if pnl is not None:
                if pnl > 0:
                    pnl_formatted = f"{theme.SUCCESS}üí∞ +{format_currency(pnl)}{theme.RESET}"
                elif pnl < 0:
                    pnl_formatted = f"{theme.ERROR}üí∏ {format_currency(pnl)}{theme.RESET}"
                else:
                    pnl_formatted = f"{theme.SUBTLE}‚ûñ {format_currency(pnl)}{theme.RESET}"
            else:
                pnl_formatted = f"{theme.SUBTLE}N/A{theme.RESET}"

            # Enhanced liquidation price display
            liq_price = p.get("liquidation_price")
            liq_display = (
                f"{theme.WARNING}‚ö†Ô∏è {format_currency(liq_price)}{theme.RESET}"
                if liq_price
                else f"{theme.SUBTLE}N/A{theme.RESET}"
            )

            table_data.append(
                [
                    f"{theme.ACCENT}{p.get('asset', '?')}{theme.RESET}",
                    position_display,
                    f"{theme.PRIMARY}{format_currency(p.get('entry_price'))}{theme.RESET}",
                    liq_display,
                    f"{theme.SUBTLE}{p.get('leverage', 0.0):.2f}x{theme.RESET}",
                    pnl_formatted,
                ]
            )

        # Sort by unrealized PNL descending (most profitable first)
        table_data.sort(key=lambda row: p.get("unrealized_pnl", 0), reverse=True)
        print(
            tabulate(
                table_data, headers=headers, tablefmt="rounded_grid", numalign="right", stralign="left"
            )
        )

    print()  # Final spacing


def display_lighter_positions(portfolio_metrics: Dict[str, Any]):
    """Display positions for Lighter perp DEX accounts."""
    print_header("Lighter Positions")

    wallet_platform_data = portfolio_metrics.get("wallet_platform_data_raw", [])
    lighter_accounts = [
        info for info in wallet_platform_data if info.get("platform") == "lighter"
    ]

    if not lighter_accounts:
        print(f"{theme.SUBTLE}No Lighter accounts tracked or no data available.{theme.RESET}")
        return

    total_value = sum(info.get("total_balance", 0.0) for info in lighter_accounts)

    print(f"\n{theme.PRIMARY}ü™ô LIGHTER SUMMARY{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 21}{theme.RESET}")
    print(f"Total Asset Value: {theme.SUCCESS}{format_currency(total_value)}{theme.RESET}")
    print(f"Tracked Accounts:  {theme.ACCENT}{len(lighter_accounts)}{theme.RESET}")

    for idx, account in enumerate(lighter_accounts, start=1):
        address = account.get("address", "N/A")
        short_addr = address[:8] + "..." + address[-6:] if address != "N/A" else "N/A"
        account_value = account.get("total_balance", 0.0)
        available = account.get("available_balance", 0.0)
        collateral = account.get("collateral", 0.0)

        print(f"\n{theme.PRIMARY}üìä ACCOUNT {idx}: {theme.ACCENT}{short_addr}{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * (17 + len(short_addr))}{theme.RESET}")
        print(f"Asset Value:    {theme.SUCCESS}{format_currency(account_value)}{theme.RESET}")
        print(f"Available:      {theme.ACCENT}{format_currency(available)}{theme.RESET}")
        print(f"Collateral:     {theme.ACCENT}{format_currency(collateral)}{theme.RESET}")

        positions = account.get("positions", [])
        if not positions:
            print(f"\n{theme.SUBTLE}No open positions{theme.RESET}")
            continue

        print(f"\n{theme.SUBTLE}Open Positions{theme.RESET}")
        headers = [
            f"{theme.PRIMARY}Asset{theme.RESET}",
            f"{theme.PRIMARY}Position{theme.RESET}",
            f"{theme.PRIMARY}Entry Price{theme.RESET}",
            f"{theme.PRIMARY}Position Value{theme.RESET}",
            f"{theme.PRIMARY}Liq. Price{theme.RESET}",
            f"{theme.PRIMARY}Unrealized PNL{theme.RESET}",
        ]
        table_data = []

        for pos in positions:
            symbol = pos.get("symbol", "N/A")
            position_size = safe_float_convert(pos.get("position", 0.0))
            position_value = safe_float_convert(pos.get("position_value", 0.0))
            entry_price = safe_float_convert(pos.get("avg_entry_price", 0.0))
            liq_price = safe_float_convert(pos.get("liquidation_price", 0.0))
            pnl = safe_float_convert(pos.get("unrealized_pnl", 0.0))

            if position_size > 0:
                direction = f"{theme.SUCCESS}üìà Long{theme.RESET}"
            elif position_size < 0:
                direction = f"{theme.ERROR}üìâ Short{theme.RESET}"
            else:
                direction = f"{theme.SUBTLE}‚ûñ Flat{theme.RESET}"

            pnl_fmt = (
                f"{theme.SUCCESS}+{format_currency(pnl)}{theme.RESET}"
                if pnl > 0
                else f"{theme.ERROR}{format_currency(pnl)}{theme.RESET}"
                if pnl < 0
                else f"{theme.SUBTLE}{format_currency(pnl)}{theme.RESET}"
            )

            table_data.append(
                [
                    f"{theme.ACCENT}{symbol}{theme.RESET}",
                    f"{abs(position_size):.4f} ({direction})",
                    f"{entry_price:,.2f}",
                    format_currency(position_value),
                    f"{liq_price:,.2f}",
                    pnl_fmt,
                ]
            )

        print(
            tabulate(
                table_data, headers=headers, tablefmt="rounded_grid", numalign="right", stralign="left"
            )
        )

    print()  # Final spacing


def display_cex_breakdown(metrics: Dict[str, Any]):
    """Clean centralized exchange breakdown with professional styling."""
    print_header("Centralized Exchange Breakdown")

    binance_total = metrics.get("binance")
    okx_total = metrics.get("okx") 
    bybit_total = metrics.get("bybit")
    backpack_total = metrics.get("backpack")
    total_cex = metrics.get("total_cex_balance", 0.0)
    failed_sources = metrics.get("failed_sources", [])

    # Clean summary
    print(f"\n{theme.PRIMARY}Exchange Summary{theme.RESET}")
    print(f"Total CEX Value: {format_currency(total_cex)}")
    active_count = sum(1 for x in [binance_total, okx_total, bybit_total, backpack_total] if x is not None and x > 0)
    print(f"Active Exchanges: {active_count}/4")
    
    if failed_sources:
        failed_cex = [s for s in failed_sources if s in ["Binance", "OKX", "Bybit", "Backpack"]]
        if failed_cex:
            print(f"Failed: {', '.join(failed_cex)}")
    
    print("‚îÄ" * 50)

    # Clean exchange overview table
    exchange_data = []
    exchanges = [
        ("Binance", binance_total),
        ("OKX", okx_total), 
        ("Bybit", bybit_total),
        ("Backpack", backpack_total),
    ]

    for name, balance in exchanges:
        if name in failed_sources:
            exchange_data.append([name, "Connection Failed", "N/A"])
        elif balance is not None and balance > 0:
            percentage = (balance / total_cex * 100) if total_cex > 0 else 0
            clean_value = f"${balance:,.0f}" if balance >= 1 else f"${balance:.2f}"
            exchange_data.append([name, clean_value, f"{percentage:.1f}%"])
        else:
            exchange_data.append([name, "No Balance", "0.0%"])

    headers = ["Exchange", "Balance", "Share"]
    print(f"\n{tabulate(exchange_data, headers=headers, tablefmt='grid')}")

    # Detailed breakdowns with cleaner styling
    if "Binance" not in failed_sources and binance_total is not None and binance_total > 0:
        binance_account_types = metrics.get("detailed_breakdowns", {}).get("binance_account_types")
        if binance_account_types:
            print(f"\n{theme.PRIMARY}Binance Account Types{theme.RESET}")
            
            account_types = binance_account_types.get("account_types", {})
            total_all = binance_account_types.get("total_all_accounts", 0.0)
            
            print(f"Total Equity: {format_currency(total_all)}")
            print("‚îÄ" * 30)
            
            account_data = []
            for account_type, balance in account_types.items():
                if balance is not None and balance > 0.01:
                    percentage = (balance / total_all * 100) if total_all > 0 else 0
                    clean_value = f"${balance:,.0f}" if balance >= 1 else f"${balance:.2f}"
                    account_data.append([account_type, clean_value, f"{percentage:.1f}%"])
                elif balance is not None and balance == 0.0:
                    account_data.append([account_type, "$0.00", "0.0%"])

            if account_data:
                headers = ["Account Type", "Balance", "Share"]
                print(f"\n{tabulate(account_data, headers=headers, tablefmt='simple')}")
            else:
                print("No account type data available")

        # Show spot account details
        stored_binance_details = metrics.get("detailed_breakdowns", {}).get("binance_details")
        if stored_binance_details:
            display_exchange_detailed_breakdown("Binance", stored_binance_details, failed_sources)

    # Other exchange details
    for exchange, key, total in [("OKX", "okx_details", okx_total), 
                                ("Bybit", "bybit_details", bybit_total),
                                ("Backpack", "backpack_details", backpack_total)]:
        if exchange not in failed_sources and total is not None and total > 0:
            stored_details = metrics.get("detailed_breakdowns", {}).get(key)
            if stored_details:
                display_exchange_detailed_breakdown(exchange, stored_details, failed_sources)

    print()


async def display_market_snapshot(portfolio_analyzer):
    """Displays a market snapshot of major and custom coins with live prices."""
    PRIMARY = Fore.WHITE + Style.BRIGHT
    SUCCESS = Fore.GREEN + Style.BRIGHT
    WARNING = Fore.YELLOW
    ERROR = Fore.RED
    ACCENT = Fore.CYAN
    SUBTLE = Style.DIM
    RESET = Style.RESET_ALL

    print(f"\n{PRIMARY}‚ö° REAL-TIME MARKET SNAPSHOT{RESET}")
    print(f"{SUBTLE}{'‚îÄ' * 30}{RESET}")

    major_coins = SUPPORTED_CRYPTO_CURRENCIES_FOR_DISPLAY # e.g., ['BTC', 'ETH', 'SOL', 'NEAR', 'APT']
    
    # Fetch prices for major coins using the portfolio_analyzer's price service
    try:
        # Use portfolio_analyzer.price_service which is enhanced_price_service
        major_coin_prices = await portfolio_analyzer.price_service.get_prices_async(major_coins)
    except Exception as e:
        print_error(f"Error fetching major coin prices: {e}")
        major_coin_prices = {coin: 0.0 for coin in major_coins}

    # Fetch custom coin data and their prices
    custom_coin_tracker = portfolio_analyzer.custom_coin_tracker # Access via analyzer
    custom_symbols = custom_coin_tracker.get_all_symbols()
    custom_coin_prices = {}
    if custom_symbols:
        try:
            # Use portfolio_analyzer.price_service for custom coins as well
            custom_coin_prices = await portfolio_analyzer.price_service.get_prices_async(custom_symbols)
        except Exception as e:
            print_error(f"Error fetching custom coin prices: {e}")
            # custom_coin_prices will remain empty or partially filled

    all_coins_data = []

    # Process major coins
    for coin in major_coins:
        price = major_coin_prices.get(coin)
        if price is not None:
            all_coins_data.append({"name": coin, "symbol": coin, "price": price})
        else:
            all_coins_data.append({"name": coin, "symbol": coin, "price": 0.0, "error": True})

    # Process custom coins
    for symbol in custom_symbols:
        coin_detail = custom_coin_tracker.get_coin_data(symbol)
        name = coin_detail.get("name", symbol)
        price = custom_coin_prices.get(symbol)
        if price is not None:
            all_coins_data.append({"name": name, "symbol": symbol, "price": price})
        else:
            # If price fetch failed for a custom coin, display its last known price or error
            last_price = coin_detail.get("last_price")
            if last_price is not None:
                 all_coins_data.append({"name": name, "symbol": symbol, "price": last_price, "stale": True})
            else:
                all_coins_data.append({"name": name, "symbol": symbol, "price": 0.0, "error": True})

    if not all_coins_data:
        print(f"{WARNING}No market data to display.{RESET}")
        return

    # Sort coins: Major coins first, then custom coins alphabetically by name
    def sort_key(item):
        is_major = item["symbol"] in major_coins
        return (not is_major, item["name"].lower())

    sorted_coins = sorted(all_coins_data, key=sort_key)

    table_data = []
    for coin_info in sorted_coins:
        name = coin_info["name"]
        symbol = coin_info["symbol"]
        price = coin_info["price"]
        
        display_name = f"{name} ({symbol})" if name.lower() != symbol.lower() else symbol
        
        price_str = format_currency(price, max_precision=True if price < 0.01 else False)

        if coin_info.get("error"):
            price_str = f"{ERROR}Error{RESET}"
        elif coin_info.get("stale"):
            price_str = f"{WARNING}{price_str} (stale){RESET}"
        else:
            price_str = f"{SUCCESS}{price_str}{RESET}"
            
        table_data.append([f"{ACCENT}{display_name}{theme.RESET}", price_str])

    headers = [f"{PRIMARY}Coin{RESET}", f"{PRIMARY}Price (USD){RESET}"]
    print(tabulate(table_data, headers=headers, tablefmt="simple", stralign="left", numalign="right"))
    print(f"{SUBTLE}{'‚îÄ' * 30}{RESET}")
    print(f"{SUBTLE}Tip: Add more coins via 'Manage Custom Coins' menu.{RESET}")


def display_exposure_analysis(portfolio_metrics: Dict[str, Any]):
    """Display comprehensive exposure analysis with simple return option."""
    from utils.display_theme import theme
    
    while True:
        # Clear screen for better visibility
        os.system('clear' if os.name == 'posix' else 'cls')
        
        # Display main exposure analysis first
        _display_main_exposure_analysis(portfolio_metrics)
        
        # Add submenu options
        print(f"\n{theme.PRIMARY}üéØ EXPOSURE ANALYSIS OPTIONS{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * 28}{theme.RESET}")
        print(f"{theme.ACCENT}1.{theme.RESET} {theme.SUBTLE}‚¨ÖÔ∏è Back to Analysis Menu{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * 50}{theme.RESET}")
        
        choice = input(f"{theme.PRIMARY}Select option (1): {theme.RESET}").strip()
        
        if choice in ("", "1", "b", "B"):
            break
        else:
            print(f"{theme.ERROR}‚ùå Invalid choice. Please press 1 or Enter.{theme.RESET}")
            input(f"\n{theme.SUBTLE}Press Enter to continue...{theme.RESET}")


def _display_main_exposure_analysis(portfolio_metrics: Dict[str, Any]):
    """
    Display the main exposure analysis (extracted from original function).
    """
    from utils.display_theme import theme
    from utils.helpers import format_currency
    from tabulate import tabulate
    import os
    
    exposure_data = portfolio_metrics.get('exposure_analysis', {})
    
    if not exposure_data or exposure_data.get('total_portfolio_value', 0) <= 0:
        print(f"\n{theme.ERROR}‚ùå EXPOSURE ANALYSIS UNAVAILABLE{theme.RESET}")
        print(f"{theme.SUBTLE}No exposure data available for analysis{theme.RESET}")
        return
    
    print(f"\n{theme.PRIMARY}üéØ PORTFOLIO EXPOSURE ANALYSIS{theme.RESET}")
    print(f"{theme.SUBTLE}{'=' * 35}{theme.RESET}")
    
    # Main metrics at the top
    total_portfolio_value = safe_float_convert(exposure_data.get('total_portfolio_value', 0))
    stable_value = safe_float_convert(exposure_data.get('stable_value', 0))
    non_stable_value = safe_float_convert(exposure_data.get('non_stable_value', 0))
    neutral_count = int(exposure_data.get('neutral_asset_count', 0) or 0)
    
    # Calculate actual percentages based on categorized assets only
    categorized_value = stable_value + non_stable_value
    
    if categorized_value > 0:
        actual_stable_pct = (stable_value / categorized_value) * 100
        actual_non_stable_pct = (non_stable_value / categorized_value) * 100
    else:
        actual_stable_pct = 0
        actual_non_stable_pct = 0
    
    # Check if we have significant neutral assets (CEX mixed)
    neutral_value = safe_float_convert(total_portfolio_value - categorized_value)
    has_neutral = neutral_count > 0 and neutral_value > 0
    
    # Risk indicator based on categorized assets
    if actual_non_stable_pct < 30:
        risk_icon = "üü¢"
        risk_text = "Conservative"
    elif actual_non_stable_pct < 70:
        risk_icon = "üü°"
        risk_text = "Balanced"
    else:
        risk_icon = "üî¥" 
        risk_text = "Aggressive"
    
    # Clean summary box - use offset-adjusted values
    print(f"\n{theme.PRIMARY}üìä PORTFOLIO RISK PROFILE{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 25}{theme.RESET}")
    
    # Get offset-adjusted values from portfolio metrics
    adjusted_portfolio_value = safe_float_convert(
        portfolio_metrics.get('adjusted_portfolio_value', total_portfolio_value)
    )
    balance_offset_raw = portfolio_metrics.get('balance_offset', 0.0)
    balance_offset = safe_float_convert(balance_offset_raw) if balance_offset_raw is not None else 0.0
    
    # If offset not found in portfolio_metrics, try loading from offset file
    if balance_offset == 0.0:
        try:
            import json
            import os
            with open('refer/portfolio_offset.json', 'r') as f:
                offset_data = json.load(f)
                balance_offset = offset_data.get('balance_offset', 0.0)
                # Calculate adjusted value if not available
                if adjusted_portfolio_value == total_portfolio_value and balance_offset != 0:
                    adjusted_portfolio_value = total_portfolio_value - balance_offset
        except (FileNotFoundError, json.JSONDecodeError):
            pass  # Use defaults
    
    # If offset exists (positive or negative), treat absolute value as additional stable assets on obscure chains
    # Negative offset means adjusted portfolio is smaller, but we still account for the obscure chain assets
    adjusted_stable_value = stable_value + abs(balance_offset) if balance_offset != 0 else stable_value
    
    # Calculate portfolio sum as: Stable Assets + Non-Stable Assets + Offset (very simple as requested)
    portfolio_sum = safe_float_convert(stable_value + non_stable_value + abs(balance_offset))
    
    # Recalculate percentages based on portfolio sum
    if portfolio_sum > 0:
        adjusted_stable_pct = (adjusted_stable_value / portfolio_sum) * 100
        adjusted_non_stable_pct = (non_stable_value / portfolio_sum) * 100
        if has_neutral:
            adjusted_neutral_pct = (neutral_value / portfolio_sum) * 100
    else:
        adjusted_stable_pct = 0
        adjusted_non_stable_pct = 0
        adjusted_neutral_pct = 0 if has_neutral else 0
    
    print(f"Portfolio Sum:      {theme.ACCENT}{format_currency(portfolio_sum)}{theme.RESET}")
    
    if balance_offset != 0:
        print(f"Stable Assets (offset adjusted): {theme.SUCCESS}{format_currency(adjusted_stable_value)}{theme.RESET} {theme.SUBTLE}({safe_float_convert(adjusted_stable_pct):.1f}%){theme.RESET}")
        print(f"  ‚îî‚îÄ Includes {format_currency(abs(balance_offset))} from offsets")
    else:
        print(f"Stable Assets:      {theme.SUCCESS}{format_currency(adjusted_stable_value)}{theme.RESET} {theme.SUBTLE}({safe_float_convert(adjusted_stable_pct):.1f}%){theme.RESET}")
    
    print(f"Non-Stable Assets:  {theme.WARNING}{format_currency(non_stable_value)}{theme.RESET} {theme.SUBTLE}({safe_float_convert(adjusted_non_stable_pct):.1f}%){theme.RESET}")
    if has_neutral:
        print(f"CEX Mixed Assets:   {theme.SUBTLE}{format_currency(neutral_value)}{theme.RESET} {theme.SUBTLE}(composition unknown){theme.RESET}")
    
    # Compute total exposure: non-stable assets excluding margin + directional margin exposure (quantity-based)
    consolidated_assets = exposure_data.get('consolidated_assets', {})
    non_margin_non_stable = 0.0
    margin_symbol_net_qty: Dict[str, float] = {}
    margin_symbol_price_weight: Dict[str, float] = {}
    margin_symbol_size_weight: Dict[str, float] = {}
    crypto_prices_snapshot = exposure_data.get('crypto_prices_snapshot', {})
    crypto_prices_live = exposure_data.get('crypto_prices', {})
    for asset_symbol, asset_info in consolidated_assets.items():
        metadata = asset_info.get('metadata', {}) or {}
        asset_is_stable = asset_info.get('is_stable')
        is_margin_asset = metadata.get('is_margin_position') or metadata.get('is_margin_reserve')
        value_usd = safe_float_convert(asset_info.get('total_value_usd', 0))
        
        if not asset_is_stable and not is_margin_asset:
            non_margin_non_stable += value_usd
        
        if is_margin_asset:
            for detail in metadata.get('margin_underlying_details', []) or []:
                # Determine signed quantity
                size_value = detail.get('size')
                if size_value is None:
                    size_value = detail.get('position')
                size = safe_float_convert(size_value, 0.0)
                if size == 0:
                    abs_size = safe_float_convert(detail.get('abs_size', 0))
                    direction_sign = detail.get('direction_sign')
                    if direction_sign in (None, 0):
                        direction_str = (detail.get('direction') or '').lower()
                        if 'short' in direction_str:
                            direction_sign = -1
                        elif 'long' in direction_str:
                            direction_sign = 1
                        else:
                            direction_sign = 1
                    size = abs_size * (direction_sign if direction_sign not in (None, 0) else 1)
                direction_sign = detail.get('direction_sign')
                if direction_sign in (None, 0):
                    direction_str = (detail.get('direction') or '').lower()
                    if 'short' in direction_str:
                        direction_sign = -1
                    elif 'long' in direction_str:
                        direction_sign = 1
                    else:
                        direction_sign = -1 if size < 0 else 1
                if size == 0:
                    continue
                symbol = (detail.get('symbol') or 'UNKNOWN').upper()
                margin_symbol_net_qty[symbol] = margin_symbol_net_qty.get(symbol, 0.0) + size
                
                price = safe_float_convert(
                    detail.get('mark_price')
                    or detail.get('entry_price')
                    or detail.get('market_price')
                    or detail.get('price'),
                    0.0,
                )
                abs_size = abs(size)
                if price <= 0 and abs_size > 0:
                    notional = safe_float_convert(detail.get('notional_value', 0))
                    if abs(notional) > 0:
                        price = abs(notional) / abs_size
                if price <= 0:
                    price = safe_float_convert(crypto_prices_snapshot.get(symbol, 0), 0.0)
                if price <= 0:
                    price = safe_float_convert(crypto_prices_live.get(symbol, 0), 0.0)
                if price > 0 and abs_size > 0:
                    margin_symbol_price_weight[symbol] = margin_symbol_price_weight.get(symbol, 0.0) + price * abs_size
                    margin_symbol_size_weight[symbol] = margin_symbol_size_weight.get(symbol, 0.0) + abs_size
    
    debug_margin_components: List[Tuple[str, float, float, float]] = []
    total_margin_exposure = 0.0
    for symbol, net_qty in margin_symbol_net_qty.items():
        if abs(net_qty) <= 1e-6:
            continue
        size_weight = margin_symbol_size_weight.get(symbol, 0.0)
        if size_weight > 0:
            price_ref = margin_symbol_price_weight.get(symbol, 0.0) / size_weight
        else:
            price_ref = safe_float_convert(
                crypto_prices_snapshot.get(symbol)
                or crypto_prices_live.get(symbol),
                0.0,
            )
        if price_ref <= 0 and size_weight > 0:
            price_ref = margin_symbol_price_weight.get(symbol, 0.0) / size_weight if size_weight else 0.0
        exposure_value = abs(net_qty) * max(price_ref, 0.0)
        total_margin_exposure += exposure_value
        debug_margin_components.append((symbol, net_qty, max(price_ref, 0.0), exposure_value))
    
    total_exposure = non_margin_non_stable + total_margin_exposure
    total_exposure_pct = (total_exposure / portfolio_sum * 100) if portfolio_sum > 0 else 0.0
    print(
        f"Total Exposure:     {theme.ACCENT}{format_currency(total_exposure)}{theme.RESET} "
        f"{theme.SUBTLE}({total_exposure_pct:.1f}% of portfolio){theme.RESET}"
    )
    
    # Update risk assessment based on adjusted percentages
    if categorized_value > 0:
        # Use adjusted non-stable percentage for risk calculation
        effective_non_stable_pct = adjusted_non_stable_pct
        if effective_non_stable_pct < 30:
            updated_risk_icon = "üü¢"
            updated_risk_text = "Conservative"
        elif effective_non_stable_pct < 70:
            updated_risk_icon = "üü°"
            updated_risk_text = "Balanced"
        else:
            updated_risk_icon = "üî¥" 
            updated_risk_text = "Aggressive"
        
        print(f"Risk Level:         {updated_risk_icon} {theme.ACCENT}{updated_risk_text}{theme.RESET}")
    else:
        print(f"Risk Level:         {theme.SUBTLE}‚ö™ Unknown (mostly CEX mixed){theme.RESET}")
    
    # Asset breakdown - simplified table format
    consolidated_assets = exposure_data.get('consolidated_assets', {})
    
    if consolidated_assets:
        print(f"\n{theme.PRIMARY}üè¶ HOLDINGS{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * 12}{theme.RESET}")
        
        # Sort assets by total value (descending)
        sorted_assets = sorted(
            consolidated_assets.items(),
            key=lambda x: x[1].get('total_value_usd', 0),
            reverse=True
        )
        
        # Clean table format - show top 15 with quantity breakdown (increased from 10)
        # Filter out dust tokens (< $1 value)
        table_data = []
        headers = ["Asset", "USD Value", "Total Amount", "Price", "% Portfolio", "Type"]
        
        assets_displayed = 0
        for symbol, asset_data in sorted_assets:
            value = safe_float_convert(asset_data.get('total_value_usd', 0))
            
            # Skip dust tokens with value < $1
            if value < 1.0:
                continue
                
            # Stop after showing 15 significant assets
            if assets_displayed >= 15:
                break
                
            assets_displayed += 1
            portfolio_pct = safe_float_convert(asset_data.get('percentage_of_portfolio', 0))
            is_stable = asset_data.get('is_stable')
            platforms = asset_data.get('platforms', {})
            metadata = asset_data.get('metadata', {}) or {}
            is_margin_position = bool(metadata.get('is_margin_position'))
            is_margin_reserve = bool(metadata.get('is_margin_reserve'))
            is_margin_asset = is_margin_position or is_margin_reserve
            if is_margin_position:
                display_symbol = f"{symbol} (Margin)"
            elif is_margin_reserve:
                display_symbol = f"{symbol} (Margin Reserve)"
            else:
                display_symbol = symbol
            
            # Get quantity and price info
            quantity_raw = asset_data.get('total_quantity', 0)
            quantity = safe_float_convert(quantity_raw)
            price_raw = asset_data.get('current_price')
            current_price = None if price_raw in (None, "") else safe_float_convert(price_raw)
            
            # Asset type indicator
            if is_stable is True:
                stability_icon = "üîí"
                asset_type = f"{theme.SUCCESS}Stable{theme.RESET}"
            elif is_stable is False:
                stability_icon = "üìà"
                asset_type = f"{theme.WARNING}Volatile{theme.RESET}"
            else:  # is_stable is None
                stability_icon = "‚ùì"
                asset_type = f"{theme.SUBTLE}Mixed{theme.RESET}"

            if is_margin_asset:
                asset_type = f"{theme.ACCENT}{'Margin Reserve' if is_margin_reserve else 'Margin'}{theme.RESET}"
            
            # Format quantity display - don't show quantity for stablecoins
            if is_margin_asset or is_stable is True:
                # For stablecoins or margin entries, don't repeat the quantity
                qty_display = f"{theme.SUBTLE}‚Äî{theme.RESET}"
            elif quantity > 0:
                if quantity >= 1:
                    qty_display = f"{theme.ACCENT}{quantity:,.4f}".rstrip('0').rstrip('.') + f" {symbol}{theme.RESET}"
                else:
                    qty_display = f"{theme.ACCENT}{quantity:.8f}".rstrip('0').rstrip('.') + f" {symbol}{theme.RESET}"
            else:
                qty_display = f"{theme.SUBTLE}‚Äî{theme.RESET}"
            
            # Format price display - don't show price for stablecoins in breakdown
            if is_margin_asset or is_stable is True:
                # For stablecoins/margin entries, don't show price info
                price_info = ""
            elif current_price is not None and current_price > 0:
                if current_price >= 1:
                    price_info = f" @ ${current_price:,.2f}"
                else:
                    price_info = f" @ ${current_price:.6f}".rstrip('0').rstrip('.')
            else:
                price_info = ""
            
            table_data.append([
                f"{stability_icon} {theme.ACCENT}{display_symbol}{theme.RESET}",
                f"{theme.PRIMARY}{format_currency(value)}{theme.RESET}",
                qty_display,
                price_info,
                f"{theme.SUBTLE}{portfolio_pct:.1f}%{theme.RESET}",
                asset_type
            ])
        
        print(tabulate(table_data, headers=headers, tablefmt="simple", stralign="left"))
        
        # Show detailed platform breakdown for significant assets (>$1 value)
        print(f"\n{theme.PRIMARY}üìç MAJOR ASSET BREAKDOWN{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * 25}{theme.RESET}")
        
        major_assets = [(symbol, data) for symbol, data in sorted_assets if data.get('total_value_usd', 0) > 1]
        
        if major_assets:
            for symbol, asset_data in major_assets:
                platforms = asset_data.get('platforms', {})
                asset_value = safe_float_convert(asset_data.get('total_value_usd', 0))
                quantity = safe_float_convert(asset_data.get('total_quantity', 0))
                price_raw = asset_data.get('current_price')
                current_price = (
                    safe_float_convert(price_raw) if price_raw not in (None, "") else None
                )
                portfolio_pct = safe_float_convert(asset_data.get('percentage_of_portfolio', 0))
                is_stable = asset_data.get('is_stable')
                metadata = asset_data.get('metadata', {}) or {}
                is_margin_position = bool(metadata.get('is_margin_position'))
                is_margin_reserve = bool(metadata.get('is_margin_reserve'))
                is_margin_asset = is_margin_position or is_margin_reserve
                if is_margin_position:
                    display_symbol = f"{symbol} (Margin)"
                elif is_margin_reserve:
                    display_symbol = f"{symbol} (Margin Reserve)"
                else:
                    display_symbol = symbol
                
                # Format price display - don't show price for stablecoins in breakdown
                if is_stable is True:
                    # For stablecoins, don't show price info since it should be ~$1.00
                    price_info = ""
                elif current_price is not None and current_price > 0:
                    if current_price >= 1:
                        price_info = f" @ ${current_price:,.2f}"
                    else:
                        price_info = f" @ ${current_price:.6f}".rstrip('0').rstrip('.')
                else:
                    price_info = ""
                
                print(f"\n{theme.ACCENT}{display_symbol}{theme.RESET} ({portfolio_pct:.1f}% of portfolio{price_info})")
                
                # Sort platforms by value
                sorted_platforms = sorted(platforms.items(), key=lambda x: safe_float_convert(x[1]), reverse=True)
                
                for platform, platform_value in sorted_platforms:
                    # Calculate quantity for this platform (proportional)
                    platform_value = safe_float_convert(platform_value)
                    total_asset_value = asset_value if asset_value > 0 else 1
                    platform_pct = platform_value / total_asset_value
                    platform_quantity = quantity * platform_pct
                    
                    if is_margin_asset:
                        label = "Margin" if is_margin_position else "Margin Reserve"
                        print(f"  ‚îî‚îÄ {theme.SUBTLE}{platform:<15}{theme.RESET}: {theme.ACCENT}{label} {format_currency(platform_value)}{theme.RESET}")
                        continue
                    
                    if platform_quantity > 0:
                        if platform_quantity >= 1:
                            qty_str = f"{platform_quantity:,.4f}".rstrip('0').rstrip('.')
                        else:
                            qty_str = f"{platform_quantity:.8f}".rstrip('0').rstrip('.')
                        
                        # For stablecoins, don't show USD value since it's redundant
                        if is_stable is True:
                            # New format: quantity only for stablecoins
                            print(f"  ‚îî‚îÄ {theme.SUBTLE}{platform:<15}{theme.RESET}: {theme.ACCENT}{qty_str} {symbol}{theme.RESET}")
                        else:
                            # New format: quantity first, then value in parentheses for non-stablecoins
                            print(f"  ‚îî‚îÄ {theme.SUBTLE}{platform:<15}{theme.RESET}: {theme.ACCENT}{qty_str} {symbol}{theme.RESET} ({theme.SUCCESS}{format_currency(platform_value)}{theme.RESET})")
                    else:
                        print(f"  ‚îî‚îÄ {theme.SUBTLE}{platform:<15}{theme.RESET}: {theme.SUCCESS}{format_currency(platform_value)}{theme.RESET}")

                if is_margin_position:
                    detailed_positions = metadata.get('margin_underlying_details') or []
                    margin_details = metadata.get('margin_underlyings', {}) or {}
                    if detailed_positions:
                        print(f"    {theme.SUBTLE}Underlying Positions:{theme.RESET}")
                        sorted_positions = sorted(
                            detailed_positions,
                            key=lambda item: -abs(safe_float_convert(item.get('margin_value', 0)))
                        )
                        max_details = 6
                        for detail in sorted_positions[:max_details]:
                            margin_value = safe_float_convert(detail.get('margin_value', 0))
                            if margin_value <= 0:
                                continue
                            symbol = detail.get('symbol', 'UNKNOWN')
                            direction_label = (detail.get('direction') or '').lower()
                            if direction_label == 'long':
                                direction_display = f"{theme.SUCCESS}Long{theme.RESET}"
                            elif direction_label == 'short':
                                direction_display = f"{theme.ERROR}Short{theme.RESET}"
                            else:
                                direction_display = None
                            
                            abs_size = abs(safe_float_convert(detail.get('abs_size', 0)))
                            size_str = None
                            if abs_size > 0:
                                if abs_size >= 1:
                                    size_str = f"{abs_size:,.4f}".rstrip('0').rstrip('.')
                                else:
                                    size_str = f"{abs_size:.8f}".rstrip('0').rstrip('.')
                            
                            liquidation_price = safe_float_convert(detail.get('liquidation_price', 0))
                            liq_str = f"${liquidation_price:,.2f}" if liquidation_price > 0 else None
                            leverage_value = safe_float_convert(detail.get('leverage', 0))
                            leverage_str = f"{leverage_value:.2f}x" if leverage_value > 0 else None
                            notional = safe_float_convert(detail.get('notional_value', 0))
                            
                            line_parts: List[str] = []
                            if direction_display and size_str:
                                line_parts.append(f"{direction_display} {size_str} {symbol}")
                            elif size_str:
                                line_parts.append(f"{size_str} {symbol}")
                            else:
                                line_parts.append(symbol)
                            
                            if leverage_str:
                                line_parts.append(f"lev {leverage_str}")
                            if notional > 0:
                                line_parts.append(f"notional {format_currency(notional)}")
                            if liq_str:
                                line_parts.append(f"liq {liq_str}")
                            unrealized_pnl = safe_float_convert(detail.get('unrealized_pnl', 0))
                            if abs(unrealized_pnl) > 0.01:
                                line_parts.append(f"PnL {format_currency(unrealized_pnl)}")
                            line_parts.append(f"margin {format_currency(margin_value)}")
                            
                            print(f"      ‚Ä¢ {' | '.join(line_parts)}")
                        if len(sorted_positions) > max_details:
                            remaining = len(sorted_positions) - max_details
                            print(f"      ‚Ä¢ ‚Ä¶ {remaining} additional position{'s' if remaining != 1 else ''}")
                    elif margin_details:
                        print(f"    {theme.SUBTLE}Underlying Positions:{theme.RESET}")
                        for underlying, underlying_value in sorted(margin_details.items(), key=lambda x: -abs(x[1])):
                            print(f"      ‚Ä¢ {underlying}: {format_currency(underlying_value)}")
        else:
            print(f"{theme.SUBTLE}No significant assets (>$1 value) to break down{theme.RESET}")
        
        if len(sorted_assets) > 15:
            # Count only non-dust assets for accurate remaining count
            non_dust_assets = [asset for _, asset in sorted_assets if asset.get('total_value_usd', 0) >= 1.0]
            if len(non_dust_assets) > 15:
                remaining = len(non_dust_assets) - 15
                remaining_value = sum(asset['total_value_usd'] for _, asset in sorted_assets[15:] if asset.get('total_value_usd', 0) >= 1.0)
                print(f"\n{theme.SUBTLE}... and {remaining} more assets worth {format_currency(remaining_value)}{theme.RESET}")
            
            # Show dust summary separately
            dust_assets = [asset for _, asset in sorted_assets if asset.get('total_value_usd', 0) < 1.0]
            if dust_assets:
                dust_count = len(dust_assets)
                dust_value = sum(asset.get('total_value_usd', 0) for asset in dust_assets)
                print(f"{theme.SUBTLE}+ {dust_count} dust tokens worth {format_currency(dust_value)} (hidden){theme.RESET}")
        
        # Non-stable composition - moved before portfolio validation
        stable_assets_map = exposure_data.get('stable_assets', {})
        if stable_assets_map and stable_value > 0:
            stable_pct_of_total = (stable_value / total_portfolio_value * 100) if total_portfolio_value else 0
            print(f"\n{theme.PRIMARY}üîí STABLE ASSET COMPOSITION{theme.RESET}")
            print(f"{theme.SUBTLE}Total: {format_currency(stable_value)} ({stable_pct_of_total:.1f}% of portfolio){theme.RESET}")
            print(f"{theme.SUBTLE}{'‚îÄ' * 30}{theme.RESET}")
            
            sorted_stable = sorted(
                [(symbol, data) for symbol, data in stable_assets_map.items()],
                key=lambda x: x[1].get('total_value_usd', 0),
                reverse=True
            )
            
            stable_table = []
            for symbol, asset_data in sorted_stable[:12]:
                value = safe_float_convert(asset_data.get('total_value_usd', 0))
                if value <= 0:
                    continue
                stable_pct = (value / stable_value * 100) if stable_value > 0 else 0
                portfolio_pct = safe_float_convert(asset_data.get('percentage_of_portfolio', 0))
                quantity = safe_float_convert(asset_data.get('total_quantity', 0))
                if quantity > 0:
                    if quantity >= 1:
                        qty_display = f"{quantity:,.2f}".rstrip('0').rstrip('.')
                    else:
                        qty_display = f"{quantity:.6f}".rstrip('0').rstrip('.')
                    quantity_str = f"{theme.ACCENT}{qty_display} {symbol}{theme.RESET}"
                else:
                    quantity_str = f"{theme.SUBTLE}‚Äî{theme.RESET}"
                
                stable_table.append([
                    f"{theme.ACCENT}{symbol}{theme.RESET}",
                    f"{theme.PRIMARY}{format_currency(value)}{theme.RESET}",
                    quantity_str,
                    f"{theme.SUCCESS}{stable_pct:.1f}%{theme.RESET}",
                    f"{theme.SUBTLE}{portfolio_pct:.1f}%{theme.RESET}",
                ])
            
            if stable_table:
                stable_headers = ["Asset", "Value", "Holdings", "% of Stable", "% of Portfolio"]
                print(tabulate(stable_table, headers=stable_headers, tablefmt="simple", stralign="left"))
                if len(sorted_stable) > 12:
                    remaining = len(sorted_stable) - 12
                    remaining_value = sum(
                        data.get('total_value_usd', 0) for _, data in sorted_stable[12:]
                    )
                    print(f"{theme.SUBTLE}... and {remaining} smaller stable assets worth {format_currency(remaining_value)}{theme.RESET}")
            else:
                print(f"{theme.SUBTLE}No stable assets above the $1 threshold to display{theme.RESET}")
        
        non_stable_assets = exposure_data.get('non_stable_assets', {})
        
        if non_stable_assets and non_stable_value > 0:
            print(f"\n{theme.PRIMARY}‚ö° NON-STABLE ASSET COMPOSITION{theme.RESET}")
            print(f"{theme.SUBTLE}Total: {format_currency(non_stable_value)} ({actual_non_stable_pct:.1f}% of portfolio){theme.RESET}")
            print(f"{theme.SUBTLE}{'‚îÄ' * 30}{theme.RESET}")
            if actual_non_stable_pct <= 10:
                print(f"{theme.SUBTLE}Note: Non-stable allocation is below 10%, showing full details for clarity{theme.RESET}")
            
            # Sort non-stable assets by their percentage within the non-stable portion
            sorted_non_stable = sorted(
                [(symbol, data) for symbol, data in non_stable_assets.items()],
                key=lambda x: x[1].get('percentage_of_non_stable', 0),
                reverse=True
            )
            
            # Enhanced table format for volatile assets
            volatile_table_data = []
            for symbol, asset_data in sorted_non_stable[:12]:  # Show top 12
                non_stable_composition_pct = safe_float_convert(
                    asset_data.get('percentage_of_non_stable', 0)
                )
                portfolio_pct = safe_float_convert(asset_data.get('percentage_of_portfolio', 0))
                value = safe_float_convert(asset_data.get('total_value_usd', 0))
                metadata = asset_data.get('metadata', {}) or {}
                is_margin_position = bool(metadata.get('is_margin_position'))
                display_symbol = f"{symbol} (Margin)" if is_margin_position else symbol
                
                # Get quantity and price info
                quantity = safe_float_convert(asset_data.get('total_quantity', 0))
                price_raw = asset_data.get('current_price')
                current_price = (
                    safe_float_convert(price_raw) if price_raw not in (None, "") else None
                )
                
                # Concentration warning icons
                if non_stable_composition_pct > 40:
                    risk_icon = f"{theme.ERROR}üî•{theme.RESET}"
                elif non_stable_composition_pct > 25:
                    risk_icon = f"{theme.WARNING}‚ö†Ô∏è{theme.RESET}"
                else:
                    risk_icon = f"{theme.SUCCESS}‚úì{theme.RESET}"
                
                # Format quantity and price
                qty_price_str = ""
                if is_margin_position:
                    qty_price_str = f"Margin {format_currency(value)}"
                elif quantity > 0:
                    if quantity >= 1:
                        qty_display = f"{quantity:,.4f}".rstrip('0').rstrip('.')
                    else:
                        qty_display = f"{quantity:.8f}".rstrip('0').rstrip('.')
                    
                    if current_price is not None and current_price > 0:
                        if current_price >= 1:
                            price_display = f"${current_price:,.2f}"
                        else:
                            price_display = f"${current_price:.6f}".rstrip('0').rstrip('.')
                        qty_price_str = f"{qty_display} @ {price_display}"
                    else:
                        qty_price_str = f"{qty_display} {symbol.lower()}"
                else:
                    qty_price_str = "‚Äî"
                
                volatile_table_data.append([
                    f"{theme.ACCENT}{display_symbol}{theme.RESET}",
                    f"{theme.PRIMARY}{format_currency(value)}{theme.RESET}",
                    f"{theme.WARNING}{non_stable_composition_pct:.1f}%{theme.RESET}",
                    f"{theme.SUBTLE}{portfolio_pct:.1f}%{theme.RESET}",
                    f"{theme.SUBTLE}{qty_price_str}{theme.RESET}",
                    risk_icon
                ])
            
            volatile_headers = ["Asset", "Value", "% Non-Stable", "% Total", "Holdings", "Risk"]
            print(tabulate(volatile_table_data, headers=volatile_headers, tablefmt="simple", stralign="left"))
            
            # Summary for volatile assets
            top_volatile = sorted_non_stable[0] if sorted_non_stable else None
            if top_volatile:
                top_symbol, top_data = top_volatile
                top_metadata = top_data.get('metadata', {}) or {}
                top_display_symbol = f"{top_symbol} (Margin)" if top_metadata.get('is_margin_position') else top_symbol
                top_pct = top_data.get('percentage_of_non_stable', 0)
                if top_pct > 50:
                    print(f"\n{theme.WARNING}‚ö†Ô∏è  {top_display_symbol} dominates non-stable holdings ({top_pct:.1f}%){theme.RESET}")
                elif len(sorted_non_stable) > 10:
                    print(f"\n{theme.SUCCESS}‚úì Well-diversified across {len(sorted_non_stable)} non-stable assets{theme.RESET}")
                else:
                    print(f"\n{theme.INFO}‚ÑπÔ∏è  {len(sorted_non_stable)} non-stable assets tracked{theme.RESET}")

        # Enhanced portfolio validation with gap analysis
        displayed_total = sum(asset_data.get('total_value_usd', 0) for _, asset_data in sorted_assets if asset_data.get('total_value_usd', 0) >= 1.0)  # Only count non-dust assets displayed
        total_all_assets = sum(asset_data.get('total_value_usd', 0) for _, asset_data in sorted_assets)
        portfolio_gap = total_portfolio_value - total_all_assets
        
        debug_info = exposure_data.get('debug_info', {})
        scaling_factor_raw = debug_info.get('scaling_factor_applied', 1.0)
        scaling_factor = safe_float_convert(scaling_factor_raw, 1.0)
        
        print(f"\n{theme.INFO}üìä PORTFOLIO VALIDATION & GAP ANALYSIS{theme.RESET}")
        print(f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
        print(f"Total Portfolio:      {format_currency(total_portfolio_value)}")
        print(f"Sum of All Assets:    {format_currency(total_all_assets)}")
        print(f"Gap/Difference:       {format_currency(portfolio_gap)}")
        
        if scaling_factor != 1.0:
            print(f"Scaling Applied:      {theme.WARNING}{scaling_factor:.3f}x{theme.RESET}")
        
        if abs(portfolio_gap) > 10:  # Alert if gap > $10
            gap_pct = (abs(portfolio_gap) / total_portfolio_value * 100) if total_portfolio_value > 0 else 0
            print(f"Gap Percentage:       {theme.WARNING}‚ö†Ô∏è  {gap_pct:.2f}%{theme.RESET}")
            
            # Provide gap analysis
            print(f"\n{theme.WARNING}üîç POSSIBLE GAP SOURCES:{theme.RESET}")
            print(f"  ‚Ä¢ Assets below $0.01 dust threshold")
            print(f"  ‚Ä¢ Exchange assets without detailed breakdown")
            print(f"  ‚Ä¢ Untracked DeFi positions or LP tokens")
            print(f"  ‚Ä¢ Cross-chain bridge assets")
            print(f"  ‚Ä¢ Manual adjustments or offsets applied")
        else:
            print(f"Gap Status:           {theme.SUCCESS}‚úÖ Values match (within tolerance){theme.RESET}")
        
        # Count only non-dust assets displayed
        non_dust_count = len([asset for _, asset in sorted_assets if asset.get('total_value_usd', 0) >= 1.0])
        displayed_count = min(15, non_dust_count)
        print(f"Top {displayed_count} Assets Total: {format_currency(displayed_total)} ({(displayed_total/total_portfolio_value*100):.1f}% of portfolio)")
    
    # Simple insights - only the most important ones
    print(f"\n{theme.PRIMARY}üí° KEY INSIGHTS{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 13}{theme.RESET}")
    
    # Handle CEX mixed assets warning
    if has_neutral:
        neutral_pct = (neutral_value / total_portfolio_value) * 100
        print(f"  {theme.WARNING}‚Ä¢ {neutral_pct:.1f}% in CEX mixed assets - breakdown unknown{theme.RESET}")
        if neutral_pct > 50:
            print(f"  {theme.SUBTLE}  Consider checking individual exchange holdings for better analysis{theme.RESET}")
    
    # Risk assessment (only for categorized assets)
    if categorized_value > 0:
        if actual_non_stable_pct > 85:
            print(f"  {theme.ERROR}‚Ä¢ High volatility exposure - consider rebalancing{theme.RESET}")
        elif actual_non_stable_pct < 15:
            print(f"  {theme.WARNING}‚Ä¢ Very conservative - may limit growth potential{theme.RESET}")
        else:
            print(f"  {theme.SUCCESS}‚Ä¢ Risk level appears appropriate for growth{theme.RESET}")
        
        # Concentration check
        if consolidated_assets:
            top_asset = max(consolidated_assets.items(), key=lambda x: x[1].get('percentage_of_portfolio', 0))
            top_asset_pct = safe_float_convert(top_asset[1].get('percentage_of_portfolio', 0))
            top_metadata = top_asset[1].get('metadata', {}) or {}
            top_display_symbol = f"{top_asset[0]} (Margin)" if top_metadata.get('is_margin_position') else top_asset[0]
            
            if top_asset_pct > 40:
                print(f"  {theme.WARNING}‚Ä¢ High concentration in {top_display_symbol} ({top_asset_pct:.1f}%){theme.RESET}")
            elif top_asset_pct < 5 and len(consolidated_assets) > 15:
                print(f"  {theme.WARNING}‚Ä¢ Very fragmented portfolio ({len(consolidated_assets)} assets){theme.RESET}")
            else:
                print(f"  {theme.SUCCESS}‚Ä¢ Good diversification across {len(consolidated_assets)} assets{theme.RESET}")
    else:
        print(f"  {theme.SUBTLE}‚Ä¢ Cannot assess risk - mostly unclassified CEX assets{theme.RESET}")
    
    # Simple footer
    asset_count = exposure_data.get('asset_count', 0)
    stable_count = exposure_data.get('stable_asset_count', 0)
    non_stable_count = exposure_data.get('non_stable_asset_count', 0)
    
    if has_neutral:
        print(f"\n{theme.SUBTLE}üìà {asset_count} assets tracked ({stable_count} stable, {non_stable_count} non-stable, {neutral_count} mixed){theme.RESET}")
    else:
        print(f"\n{theme.SUBTLE}üìà {asset_count} assets tracked ({stable_count} stable, {non_stable_count} non-stable){theme.RESET}")
    print()


def display_eth_balance_breakdown(portfolio_metrics: Dict[str, Any]):
    """
    EVM Wallet Balance Breakdown - Compare standard vs enhanced data
    Shows detailed analysis mimicking the enhanced debank scraper reports.
    """
    from utils.display_theme import theme
    from utils.helpers import format_currency
    from tabulate import tabulate
    import os
    import json
    from pathlib import Path
    
    # Clear screen
    os.system('clear' if os.name == 'posix' else 'cls')
    
    print(f"\n{theme.PRIMARY}üîó EVM WALLET BALANCE BREAKDOWN{theme.RESET}")
    print(f"{theme.SUBTLE}{'=' * 35}{theme.RESET}")
    
    # Get wallet data from portfolio metrics
    wallet_data = portfolio_metrics.get('wallet_platform_data_raw', [])
    eth_exposure_data = portfolio_metrics.get('eth_exposure_data', {})
    
    # Extract standard DeBankc balances for Ethereum addresses
    standard_eth_balances = {}
    total_standard_eth = 0
    eth_addresses = []
    
    for wallet_info in wallet_data:
        if wallet_info.get('chain') == 'ethereum':
            address = wallet_info.get('address', 'Unknown')
            balance = wallet_info.get('total_balance', 0)
            standard_eth_balances[address] = balance
            total_standard_eth += balance
            eth_addresses.append(address)
    
    if not eth_addresses:
        print(f"\n{theme.WARNING}‚ö†Ô∏è NO ETHEREUM ADDRESSES FOUND{theme.RESET}")
        print(f"{theme.SUBTLE}No Ethereum wallets configured in the system{theme.RESET}")
        input(f"\n{theme.SUBTLE}Press Enter to continue...{theme.RESET}")
        return
    
    print(f"\n{theme.INFO}üìä Found {len(eth_addresses)} Ethereum addresses{theme.RESET}")
    print(f"{theme.SUBTLE}Standard DeBankc Total: {format_currency(total_standard_eth)}{theme.RESET}")
    
    # Try to load enhanced data from organized folders and legacy files
    enhanced_data = {}
    
    # Check if we have analysis folder context from past analysis viewing
    analysis_folder = portfolio_metrics.get('_analysis_folder')
    
    if analysis_folder and Path(analysis_folder).exists():
        # SPECIFIC ANALYSIS SESSION: Load from the exact folder
        print(f"\n{theme.INFO}üîç Loading enhanced data from specific analysis session...{theme.RESET}")
        print(f"{theme.SUCCESS}üéØ Target folder: {analysis_folder}{theme.RESET}")
        
        analysis_path = Path(analysis_folder)
        json_files = list(analysis_path.glob("wallet_breakdown_0x*.json"))
        
        if json_files:
            print(f"{theme.SUCCESS}‚úÖ Found {len(json_files)} enhanced wallet files{theme.RESET}")
            
            # Load enhanced data for each address
            for json_file in json_files:
                try:
                    with open(json_file, 'r') as f:
                        file_data = json.load(f)
                    
                    # Extract address from file data or filename
                    address = file_data.get('address')
                    if not address:
                        # Try to extract from filename
                        filename = json_file.name
                        if 'wallet_breakdown_0x' in filename:
                            address_part = filename.split('wallet_breakdown_')[1].split('.json')[0]
                            # Find matching full address
                            for full_addr in eth_addresses:
                                if full_addr.lower().startswith(address_part.lower()):
                                    address = full_addr
                                    break
                    
                    if address and address in eth_addresses:
                        enhanced_data[address] = file_data
                        print(f"{theme.SUCCESS}  ‚úÖ Loaded data for {address[:8]}...{address[-6:]}{theme.RESET}")
                    
                except Exception as e:
                    print(f"{theme.ERROR}  ‚ùå Error loading {json_file.name}: {e}{theme.RESET}")
                    continue
        else:
            print(f"{theme.WARNING}‚ö†Ô∏è No enhanced wallet files found in this analysis session{theme.RESET}")
    
    else:
        # NO SPECIFIC FOLDER: Search all organized folders (for live analysis or refresh)
        print(f"\n{theme.INFO}üîç Searching for enhanced wallet data in all analysis sessions...{theme.RESET}")
        exported_data_path = Path("exported_data")
        
        if exported_data_path.exists():
            # Search in organized analysis folders first
            analysis_folders = list(exported_data_path.glob("analysis_*/"))
            json_files = []
            
            for analysis_folder_path in analysis_folders:
                json_files.extend(analysis_folder_path.glob("wallet_breakdown_0x*.json"))
            
            # Also check root folder for legacy files
            json_files.extend(exported_data_path.glob("live_analysis_0x*.json"))
            json_files.extend(exported_data_path.glob("wallet_breakdown_0x*.json"))
            
            # Sort by modification time to get most recent first
            if json_files:
                json_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)
                print(f"{theme.SUCCESS}‚úÖ Found {len(json_files)} enhanced wallet files{theme.RESET}")
                
                # Track which addresses we've actually loaded (not duplicates)
                loaded_addresses = set()
                
                # Load enhanced data for each address
                for json_file in json_files:
                    try:
                        with open(json_file, 'r') as f:
                            file_data = json.load(f)
                        
                        # Extract address from file data or filename
                        address = file_data.get('address')
                        if not address:
                            # Try to extract from filename
                            filename = json_file.name
                            if 'wallet_breakdown_0x' in filename:
                                address_part = filename.split('wallet_breakdown_')[1].split('.json')[0]
                            elif 'live_analysis_0x' in filename:
                                address_part = filename.split('_')[2]
                            else:
                                continue
                            
                            # Find matching full address
                            for full_addr in eth_addresses:
                                if full_addr.lower().startswith(address_part.lower()):
                                    address = full_addr
                                    break
                        
                        if address and address in eth_addresses:
                            # Only show loading message for new addresses (not overwrites)
                            if address not in loaded_addresses:
                                enhanced_data[address] = file_data
                                loaded_addresses.add(address)
                                print(f"{theme.SUCCESS}  ‚úÖ Loaded data for {address[:8]}...{address[-6:]}{theme.RESET}")
                            else:
                                # Silently overwrite with more recent data (files are sorted by mod time)
                                enhanced_data[address] = file_data
                        
                    except Exception as e:
                        print(f"{theme.ERROR}  ‚ùå Error loading {json_file.name}: {e}{theme.RESET}")
                        continue
                
                # Show summary of what was actually loaded
                if loaded_addresses:
                    duplicate_count = len(json_files) - len(loaded_addresses)
                    if duplicate_count > 0:
                        print(f"{theme.SUBTLE}  üìÅ {duplicate_count} duplicate files ignored (kept most recent){theme.RESET}")
            else:
                print(f"{theme.WARNING}‚ö†Ô∏è No enhanced wallet files found{theme.RESET}")
        else:
            print(f"{theme.WARNING}‚ö†Ô∏è exported_data folder not found{theme.RESET}")
    
    # Analysis and comparison
    if not enhanced_data:
        print(f"\n{theme.ERROR}‚ùå NO ENHANCED DATA AVAILABLE{theme.RESET}")
        print(f"{theme.SUBTLE}Run a live analysis to generate enhanced wallet breakdowns{theme.RESET}")
        input(f"\n{theme.SUBTLE}Press Enter to continue...{theme.RESET}")
        return
    
    # 1. COMPARISON TABLE
    print(f"\n{theme.PRIMARY}üìä STANDARD vs ENHANCED COMPARISON{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 40}{theme.RESET}")
    
    
    comparison_data = []
    headers = ["Address", "Standard DeBankc", "Enhanced Scraper", "Difference", "Tokens", "Protocols", "Status"]
    
    total_enhanced = 0
    successful_addresses = 0
    
    for address in eth_addresses:
        address_short = f"{address[:8]}...{address[-6:]}"
        standard_balance = standard_eth_balances.get(address, 0)
        
        if address in enhanced_data:
            enhanced_info = enhanced_data[address]
            enhanced_balance = enhanced_info.get('total_usd_value', 0)
            tokens = enhanced_info.get('tokens', [])
            protocols = enhanced_info.get('protocols', [])
            
            total_enhanced += enhanced_balance
            successful_addresses += 1
            
            # Calculate difference
            difference = enhanced_balance - standard_balance
            
            # Status and color coding
            if abs(difference) < 10:
                diff_color = theme.SUCCESS
                status = "‚úÖ"
            elif abs(difference) < 100:
                diff_color = theme.WARNING  
                status = "‚ö†Ô∏è"
            else:
                diff_color = theme.ERROR
                status = "‚ùå"
            
            # Format difference with sign
            if difference >= 0:
                diff_display = f"{diff_color}+{format_currency(difference)}{theme.RESET}"
            else:
                diff_display = f"{diff_color}{format_currency(difference)}{theme.RESET}"
            
            comparison_data.append([
                f"{theme.ACCENT}{address_short}{theme.RESET}",
                f"{theme.PRIMARY}{format_currency(standard_balance)}{theme.RESET}",
                f"{theme.PRIMARY}{format_currency(enhanced_balance)}{theme.RESET}",
                diff_display,
                f"{theme.SUBTLE}{len(tokens)}{theme.RESET}",
                f"{theme.SUBTLE}{len(protocols)}{theme.RESET}",
                status
            ])
        else:
            comparison_data.append([
                f"{theme.ACCENT}{address_short}{theme.RESET}",
                f"{theme.PRIMARY}{format_currency(standard_balance)}{theme.RESET}",
                f"{theme.ERROR}No Data{theme.RESET}",
                f"{theme.ERROR}N/A{theme.RESET}",
                f"{theme.SUBTLE}‚Äî{theme.RESET}",
                f"{theme.SUBTLE}‚Äî{theme.RESET}",
                "‚ùå"
            ])
    
    print(tabulate(comparison_data, headers=headers, tablefmt="simple", stralign="left"))
    
    # 2. SUMMARY STATISTICS
    method_difference = total_enhanced - total_standard_eth
    
    print(f"\n{theme.PRIMARY}üìà SUMMARY STATISTICS{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 20}{theme.RESET}")
    print(f"Total Addresses:        {theme.ACCENT}{len(eth_addresses)}{theme.RESET}")
    print(f"Enhanced Data Available: {theme.SUCCESS}{successful_addresses}{theme.RESET}")
    print(f"Coverage:               {theme.ACCENT}{(successful_addresses/len(eth_addresses)*100):.1f}%{theme.RESET}")
    
    print(f"\n{theme.PRIMARY}üí∞ BALANCE COMPARISON{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 20}{theme.RESET}")
    print(f"Standard DeBankc Total: {theme.PRIMARY}{format_currency(total_standard_eth)}{theme.RESET}")
    print(f"Enhanced Scraper Total: {theme.PRIMARY}{format_currency(total_enhanced)}{theme.RESET}")
    
    if method_difference >= 0:
        method_diff_display = f"{theme.SUCCESS}+{format_currency(method_difference)}{theme.RESET}"
    else:
        method_diff_display = f"{theme.WARNING}{format_currency(method_difference)}{theme.RESET}"
    
    print(f"Method Difference:      {method_diff_display}")
    
    if total_standard_eth > 0:
        method_diff_pct = (method_difference / total_standard_eth) * 100
        print(f"Difference Percentage:  {theme.WARNING}{method_diff_pct:+.2f}%{theme.RESET}")
    
    # 3. DETAILED ANALYSIS (mimicking enhanced debank scraper)
    if enhanced_data:
        print(f"\n{theme.PRIMARY}üîç DETAILED WALLET ANALYSIS{theme.RESET}")
        print(f"{theme.SUBTLE}{'‚îÄ' * 25}{theme.RESET}")
        
        # Find the largest wallet for detailed breakdown
        largest_wallet = max(enhanced_data.items(), key=lambda x: x[1].get('total_usd_value', 0))
        largest_addr, largest_data = largest_wallet
        
        print(f"\n{theme.ACCENT}üèÜ LARGEST WALLET: {largest_addr[:8]}...{largest_addr[-6:]}{theme.RESET}")
        print(f"Total Value: {theme.PRIMARY}{format_currency(largest_data.get('total_usd_value', 0))}{theme.RESET}")
        
        # Token breakdown
        tokens = largest_data.get('tokens', [])
        if tokens:
            print(f"\n{theme.INFO}ü™ô TOKEN BREAKDOWN ({len(tokens)} tokens):{theme.RESET}")
            
            # Sort tokens by value
            sorted_tokens = sorted(tokens, key=lambda t: t.get('usd_value', 0), reverse=True)
            
            token_table = []
            for token in sorted_tokens[:10]:  # Show top 10
                symbol = token.get('symbol', 'Unknown')
                amount = token.get('amount', 0)
                usd_value = token.get('usd_value', 0)
                category = token.get('category', 'other')
                
                # Category icon
                if category == 'stable':
                    cat_icon = "üîí"
                elif category == 'eth_exposure':
                    cat_icon = "üíé"
                elif category == 'eth_staking':
                    cat_icon = "ü•©"
                else:
                    cat_icon = "üìà"
                
                token_table.append([
                    f"{cat_icon} {theme.ACCENT}{symbol}{theme.RESET}",
                    f"{theme.SUBTLE}{amount:,.4f}".rstrip('0').rstrip('.'),
                    f"{theme.PRIMARY}{format_currency(usd_value)}{theme.RESET}",
                    f"{theme.SUBTLE}{category}{theme.RESET}"
                ])
            
            print(tabulate(token_table, headers=["Token", "Amount", "USD Value", "Category"], tablefmt="simple"))
        
        # Protocol breakdown
        protocols = largest_data.get('protocols', [])
        if protocols:
            print(f"\n{theme.INFO}üèõÔ∏è PROTOCOL BREAKDOWN ({len(protocols)} protocols):{theme.RESET}")
            
            # Sort protocols by value
            sorted_protocols = sorted(protocols, key=lambda p: p.get('total_value', 0), reverse=True)
            
            protocol_table = []
            for protocol in sorted_protocols[:8]:  # Show top 8
                name = protocol.get('name', 'Unknown')
                total_value = protocol.get('total_value', 0)
                chain = protocol.get('chain', 'unknown')
                
                # Chain icon
                chain_icon = "üîó"
                if chain.lower() == 'ethereum':
                    chain_icon = "‚ü†"
                elif chain.lower() == 'arbitrum':
                    chain_icon = "üîµ"
                elif chain.lower() == 'polygon':
                    chain_icon = "üü£"
                elif chain.lower() == 'base':
                    chain_icon = "üî∑"
                
                protocol_table.append([
                    f"{theme.ACCENT}{name}{theme.RESET}",
                    f"{theme.PRIMARY}{format_currency(total_value)}{theme.RESET}",
                    f"{chain_icon} {theme.SUBTLE}{chain}{theme.RESET}"
                ])
            
            print(tabulate(protocol_table, headers=["Protocol", "USD Value", "Chain"], tablefmt="simple"))
        
        # Show exposure breakdown for largest wallet
        largest_data = max(enhanced_data.values(), key=lambda x: x.get('total_usd_value', 0))
        
        # Calculate exposure breakdown on-the-fly from raw token data
        exposure_breakdown = {
            'stable': 0.0,
            'eth_exposure': 0.0,
            'eth_staking': 0.0,
            'other_crypto': 0.0
        }
        
        for token in largest_data.get('tokens', []):
            category = token.get('category', 'other_crypto')
            if category in exposure_breakdown:
                exposure_breakdown[category] += token.get('usd_value', 0)
            else:
                exposure_breakdown['other_crypto'] += token.get('usd_value', 0)
        
        if exposure_breakdown:
            print(f"\n{theme.PRIMARY}üìä EXPOSURE BREAKDOWN (Largest Wallet){theme.RESET}")
            print(f"{theme.SUBTLE}{'‚îÄ' * 35}{theme.RESET}")
            
            total_categorized = sum(exposure_breakdown.values())
            
            for category, value in exposure_breakdown.items():
                if value > 0:
                    percentage = (value / total_categorized * 100) if total_categorized > 0 else 0
                    category_display = {
                        'stable': 'üîí Stable',
                        'eth_exposure': 'üíé ETH Exposure', 
                        'eth_staking': 'ü•© ETH Staking',
                        'other_crypto': 'üìà Other Crypto'
                    }.get(category, category)
                    
                    print(f"  {category_display}: {format_currency(value)} ({percentage:.1f}%)")
    
    # 4. INSIGHTS AND RECOMMENDATIONS
    print(f"\n{theme.PRIMARY}üí° KEY INSIGHTS{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 13}{theme.RESET}")
    
    if method_difference > 100:
        print(f"  {theme.SUCCESS}‚Ä¢ Enhanced method captures {format_currency(method_difference)} more value{theme.RESET}")
        print(f"  {theme.INFO}‚Ä¢ This suggests the enhanced scraper finds additional tokens/protocols{theme.RESET}")
    elif method_difference < -100:
        print(f"  {theme.WARNING}‚Ä¢ Standard method shows {format_currency(abs(method_difference))} more value{theme.RESET}")
        print(f"  {theme.INFO}‚Ä¢ This may indicate parsing differences or timing variations{theme.RESET}")
    else:
        print(f"  {theme.SUCCESS}‚Ä¢ Both methods show similar total values (difference < $100){theme.RESET}")
        print(f"  {theme.INFO}‚Ä¢ This indicates good consistency between approaches{theme.RESET}")
    
    if successful_addresses < len(eth_addresses):
        missing = len(eth_addresses) - successful_addresses
        print(f"  {theme.WARNING}‚Ä¢ {missing} addresses missing enhanced data - run live analysis to update{theme.RESET}")
    
    # Show data freshness
    if enhanced_data:
        timestamps = []
        for data in enhanced_data.values():
            timestamp_str = data.get('timestamp', '')
            if timestamp_str:
                try:
                    from datetime import datetime, timezone
                    # Handle both with and without timezone info
                    if timestamp_str.endswith('Z'):
                        timestamp = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
                    elif '+' in timestamp_str or timestamp_str.endswith('UTC'):
                        timestamp = datetime.fromisoformat(timestamp_str)
                    else:
                        # Assume UTC if no timezone info
                        timestamp = datetime.fromisoformat(timestamp_str).replace(tzinfo=timezone.utc)
                    timestamps.append(timestamp)
                except:
                    continue
        
        if timestamps:
            latest_timestamp = max(timestamps)
            from datetime import datetime, timezone
            # Ensure both datetimes are timezone-aware
            now_utc = datetime.now(timezone.utc)
            if latest_timestamp.tzinfo is None:
                latest_timestamp = latest_timestamp.replace(tzinfo=timezone.utc)
            
            age_hours = (now_utc - latest_timestamp).total_seconds() / 3600
            
            if age_hours < 1:
                freshness_color = theme.SUCCESS
                freshness_text = f"Very fresh (< 1 hour old)"
            elif age_hours < 24:
                freshness_color = theme.WARNING
                freshness_text = f"Recent ({age_hours:.1f} hours old)"
            else:
                freshness_color = theme.ERROR
                freshness_text = f"Stale ({age_hours/24:.1f} days old)"
            
            print(f"  {freshness_color}‚Ä¢ Data freshness: {freshness_text}{theme.RESET}")
    
    # 4. DOUBLE COUNTING ANALYSIS (permanent warning for users)
    print(f"\n{theme.PRIMARY}üîç DOUBLE COUNTING ANALYSIS{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 25}{theme.RESET}")
    
    # Check for potential double counting issues across all wallets
    total_fallback_protocols = 0
    total_fallback_value = 0
    wallets_with_fallback = []
    wallets_with_generic_protocols = []
    
    for address, wallet_data in enhanced_data.items():
        protocols = wallet_data.get('protocols', [])
        
        # Check for fallback 'Wallet' protocols that were filtered out
        fallback_count = 0
        fallback_value = 0
        
        for protocol in protocols:
            # Check for the exact criteria we filter in the enhanced scraper
            if (protocol.get('name') == 'Wallet' and 
                protocol.get('chain') == 'unknown' and 
                protocol.get('source') == 'reverted_simple_parsing'):
                fallback_count += 1
                fallback_value += protocol.get('total_value', 0)
                total_fallback_protocols += 1
                total_fallback_value += protocol.get('total_value', 0)
        
        if fallback_count > 0:
            wallets_with_fallback.append({
                'address': address,
                'count': fallback_count,
                'value': fallback_value
            })
        
        # Also check for other potentially problematic protocols
        generic_protocols = []
        for protocol in protocols:
            if protocol.get('name') in ['Portfolio', 'Total', 'Balance']:
                generic_protocols.append(protocol.get('name'))
        
        if generic_protocols:
            wallets_with_generic_protocols.append({
                'address': address,
                'protocols': generic_protocols
            })
    
    # Display double counting status
    if total_fallback_protocols > 0:
        print(f"  {theme.WARNING}‚ö†Ô∏è  FALLBACK PROTOCOLS DETECTED{theme.RESET}")
        print(f"  {theme.ERROR}‚Ä¢ {total_fallback_protocols} fallback 'Wallet' protocols worth {format_currency(total_fallback_value)}{theme.RESET}")
        print(f"  {theme.SUCCESS}‚Ä¢ These protocols have been automatically filtered to prevent double counting{theme.RESET}")
        print(f"  {theme.INFO}‚Ä¢ Affected wallets: {len(wallets_with_fallback)}{theme.RESET}")
        
        # Show details for affected wallets
        for wallet_info in wallets_with_fallback:
            addr_short = f"{wallet_info['address'][:8]}...{wallet_info['address'][-6:]}"
            print(f"    {theme.SUBTLE}‚Ä¢ {addr_short}: {wallet_info['count']} fallback protocols ({format_currency(wallet_info['value'])}){theme.RESET}")
        
        print(f"  {theme.SUCCESS}‚úÖ Validation: All fallback protocols excluded from totals{theme.RESET}")
    else:
        print(f"  {theme.SUCCESS}‚úÖ NO DOUBLE COUNTING DETECTED{theme.RESET}")
        print(f"  {theme.SUCCESS}‚Ä¢ All protocols appear to be legitimate and unique{theme.RESET}")
        print(f"  {theme.INFO}‚Ä¢ No fallback 'Wallet' protocols found{theme.RESET}")
    
    # Check for other potential issues
    if wallets_with_generic_protocols:
        print(f"  {theme.WARNING}‚ö†Ô∏è  GENERIC PROTOCOL NAMES DETECTED{theme.RESET}")
        for wallet_info in wallets_with_generic_protocols:
            addr_short = f"{wallet_info['address'][:8]}...{wallet_info['address'][-6:]}"
            protocols_str = ', '.join(wallet_info['protocols'])
            print(f"    {theme.SUBTLE}‚Ä¢ {addr_short}: {protocols_str}{theme.RESET}")
        print(f"  {theme.INFO}‚Ä¢ These may indicate parsing issues but are included in totals{theme.RESET}")
    
    # 5. INSIGHTS AND RECOMMENDATIONS
    print(f"\n{theme.PRIMARY}üí° KEY INSIGHTS{theme.RESET}")
    print(f"{theme.SUBTLE}{'‚îÄ' * 13}{theme.RESET}")
    
    if method_difference > 100:
        print(f"  {theme.SUCCESS}‚Ä¢ Enhanced method captures {format_currency(method_difference)} more value{theme.RESET}")
        print(f"  {theme.INFO}‚Ä¢ This suggests the enhanced scraper finds additional tokens/protocols{theme.RESET}")
    elif method_difference < -100:
        print(f"  {theme.WARNING}‚Ä¢ Standard method shows {format_currency(abs(method_difference))} more value{theme.RESET}")
        print(f"  {theme.INFO}‚Ä¢ This may indicate parsing differences or timing variations{theme.RESET}")
    else:
        print(f"  {theme.SUCCESS}‚Ä¢ Both methods show similar total values (difference < $100){theme.RESET}")
        print(f"  {theme.INFO}‚Ä¢ This indicates good consistency between approaches{theme.RESET}")
    
    if successful_addresses < len(eth_addresses):
        missing = len(eth_addresses) - successful_addresses
        print(f"  {theme.WARNING}‚Ä¢ {missing} addresses missing enhanced data - run live analysis to update{theme.RESET}")
    
    # Show data freshness
    if enhanced_data:
        timestamps = []
        for data in enhanced_data.values():
            timestamp_str = data.get('timestamp', '')
            if timestamp_str:
                try:
                    from datetime import datetime, timezone
                    # Handle both with and without timezone info
                    if timestamp_str.endswith('Z'):
                        timestamp = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
                    elif '+' in timestamp_str or timestamp_str.endswith('UTC'):
                        timestamp = datetime.fromisoformat(timestamp_str)
                    else:
                        # Assume UTC if no timezone info
                        timestamp = datetime.fromisoformat(timestamp_str).replace(tzinfo=timezone.utc)
                    timestamps.append(timestamp)
                except:
                    continue
        
        if timestamps:
            latest_timestamp = max(timestamps)
            from datetime import datetime, timezone
            # Ensure both datetimes are timezone-aware
            now_utc = datetime.now(timezone.utc)
            if latest_timestamp.tzinfo is None:
                latest_timestamp = latest_timestamp.replace(tzinfo=timezone.utc)
            
            age_hours = (now_utc - latest_timestamp).total_seconds() / 3600
            
            if age_hours < 1:
                freshness_color = theme.SUCCESS
                freshness_text = f"Very fresh (< 1 hour old)"
            elif age_hours < 24:
                freshness_color = theme.WARNING
                freshness_text = f"Recent ({age_hours:.1f} hours old)"
            else:
                freshness_color = theme.ERROR
                freshness_text = f"Stale ({age_hours/24:.1f} days old)"
            
            print(f"  {freshness_color}‚Ä¢ Data freshness: {freshness_text}{theme.RESET}")
    
    input(f"\n{theme.SUBTLE}Press Enter to continue...{theme.RESET}")


# -------------------------
# Helper: Detailed protocol view
# -------------------------

def _display_protocol_details(protocol: Dict[str, Any]):
    """Display detailed positions for a single protocol."""
    from utils.display_theme import theme
    from utils.helpers import format_currency
    from tabulate import tabulate
    import os

    # Clear screen for a focused view
    os.system('clear' if os.name == 'posix' else 'cls')

    name = protocol.get('name', 'Unknown')
    chain = protocol.get('chain', 'unknown').capitalize()
    total_val = protocol.get('total_value', protocol.get('value', 0))

    print(f"{theme.PRIMARY}üèõÔ∏è PROTOCOL DETAILS{theme.RESET}")
    print(f"{theme.ACCENT}{name}{theme.RESET} on {chain}")
    print(f"Total Value: {theme.SUCCESS}{format_currency(total_val)}{theme.RESET}\n")

    positions = protocol.get('positions', [])

    if positions:
        pos_table = []
        for pos in positions:
            label = pos.get('label', '')
            asset = pos.get('asset', '')
            usd_val = pos.get('usd_value', pos.get('value', 0))
            header_type = pos.get('header_type', '')
            pos_table.append([
                label,
                asset,
                header_type if header_type else '-',
                format_currency(usd_val),
            ])

        print(tabulate(pos_table, headers=["Label", "Asset/Amount", "Type", "USD Value"], tablefmt="simple"))
    else:
        print(f"{theme.SUBTLE}No position information available{theme.RESET}")

    input(f"\n{theme.SUBTLE}Press Enter to return...{theme.RESET}")


def _display_merged_stable_breakdown(tokens: List[Dict[str, Any]], protocols: List[Dict[str, Any]]):
    """Helper function to display merged stable breakdown from both token and protocol data."""
    from utils.display_theme import theme
    from utils.helpers import format_currency
    
    stable_bases = {'USDC', 'USDT', 'DAI', 'FDUSD', 'USDE', 'FRAX', 'TUSD', 'PYUSD', 'GUSD', 'PAX', 'BUSD', 'GHO', 'CRVUSD'}
    stable_patterns = ['USD']
    chain_icons = {"Ethereum": "‚ü†", "Arbitrum": "üîµ", "Polygon": "üü£", "Base": "üî∑", "Optimism": "üî¥", "Solana": "üåû", "Sonic": "‚ö°", "Soneium": "üü°", "Linea": "üü¢", "Ink": "üñãÔ∏è", "Lisk": "üî∂", "Unichain": "ü¶Ñ", "Gravity": "üåç", "Lens": "üì∑"}
    
    def _normalize_symbol(symbol: str) -> str:
        return (symbol or "").replace(" ", "").upper()

    def _is_base_stable(token: str) -> bool:
        clean = _normalize_symbol(token)
        if not clean:
            return False
        if clean in stable_bases:
            return True
        for pat in stable_patterns:
            if pat in clean:
                return True
        return False

    def is_stable(symbol: str) -> bool:
        clean = _normalize_symbol(symbol)
        if '+' in clean:
            parts = [part for part in clean.split('+') if part]
            return bool(parts) and all(_is_base_stable(part) for part in parts)
        if '/' in clean or '-' in clean:
            return False
        return _is_base_stable(clean)

    def is_pool_stable(symbol: str) -> bool:
        clean = _normalize_symbol(symbol)
        if '+' in clean:
            parts = [part for part in clean.split('+') if part]
            return bool(parts) and all(_is_base_stable(part) for part in parts)
        if '/' in clean or '-' in clean:
            return False
        return _is_base_stable(clean)
    
    # 1. Collect stable tokens from token breakdown
    token_stables = {}  # symbol -> {chain -> usd}
    for token in tokens:
        symbol = token.get('symbol', '').upper()
        chain = token.get('chain', 'unknown').capitalize()
        value = token.get('usd_value', 0)
        category = token.get('category', 'other_crypto')
        is_token_stable = is_stable(symbol) or category == 'stable'
        if is_token_stable:
            if symbol not in token_stables:
                token_stables[symbol] = {}
            if chain not in token_stables[symbol]:
                token_stables[symbol][chain] = 0
            token_stables[symbol][chain] += value
    
    # 2. Collect stable tokens from protocol breakdown
    protocol_stables = {}  # symbol -> {chain -> {(protocol, type) -> usd}}
    protocol_stable_totals = {}  # symbol -> {chain -> total_usd}
    for proto in protocols:
        chain = proto.get('chain', 'unknown').capitalize()
        proto_name = proto.get('name', 'Unknown')
        positions = proto.get('positions', []) or []
        position_total_value = 0.0
        for pos in positions:
            raw = (pos.get('asset') or pos.get('label') or '').strip()
            parts = raw.split()
            if len(parts) > 1 and any(ch.isdigit() for ch in parts[0]):
                symbol = parts[-1].upper()
            else:
                symbol = raw.upper()
            usd = pos.get('usd_value', pos.get('value', 0)) or 0
            try:
                usd = float(usd)
            except Exception:
                usd = 0
            position_total_value += usd
            ptype = pos.get('header_type', '-') or '-'
            is_borrowed = str(ptype).lower() == 'borrowed'
            if is_pool_stable(symbol):
                if symbol not in protocol_stables:
                    protocol_stables[symbol] = {}
                    protocol_stable_totals[symbol] = {}
                if chain not in protocol_stables[symbol]:
                    protocol_stables[symbol][chain] = {}
                    protocol_stable_totals[symbol][chain] = 0
                if is_borrowed:
                    protocol_stables[symbol][chain][(proto_name, ptype)] = protocol_stables[symbol][chain].get((proto_name, ptype), 0) - usd
                    protocol_stable_totals[symbol][chain] -= usd
                else:
                    protocol_stables[symbol][chain][(proto_name, ptype)] = protocol_stables[symbol][chain].get((proto_name, ptype), 0) + usd
                    protocol_stable_totals[symbol][chain] += usd

        if (proto_name or '').lower() == 'hyperliquid':
            total_value = proto.get('total_value', proto.get('value', 0)) or 0
            residual = total_value - position_total_value
            if residual > 0.01:
                symbol = 'USDC'
                if symbol not in protocol_stables:
                    protocol_stables[symbol] = {}
                    protocol_stable_totals[symbol] = {}
                if chain not in protocol_stables[symbol]:
                    protocol_stables[symbol][chain] = {}
                    protocol_stable_totals[symbol][chain] = 0
                label = f"{proto_name} Collateral"
                protocol_stables[symbol][chain][(label, 'Collateral')] = (
                    protocol_stables[symbol][chain].get((label, 'Collateral'), 0) + residual
                )
                protocol_stable_totals[symbol][chain] += residual
    
    # 3. Merge both datasets by summing values for each (symbol, chain)
    merged_stables = {}  # symbol -> {chain -> {"usd": float, "protocols": dict, "has_protocol_data": bool, "token_usd": float}}
    all_symbols = set(token_stables.keys()) | set(protocol_stables.keys())
    for symbol in all_symbols:
        merged_stables[symbol] = {}
        chains = set(token_stables.get(symbol, {}).keys()) | set(protocol_stables.get(symbol, {}).keys())
        for chain in chains:
            token_usd = token_stables.get(symbol, {}).get(chain, 0)
            proto_usd = protocol_stable_totals.get(symbol, {}).get(chain, 0)
            total_usd = token_usd + proto_usd
            has_protocol_data = chain in protocol_stables.get(symbol, {}) and bool(protocol_stables[symbol][chain])
            protocols_dict = protocol_stables.get(symbol, {}).get(chain, {}) if has_protocol_data else {}
            merged_stables[symbol][chain] = {
                "usd": total_usd,
                "protocols": protocols_dict,
                "has_protocol_data": has_protocol_data,
                "token_usd": token_usd  # Store token-only value for display
            }
    
    # 4. Display merged stable breakdown
    if merged_stables:
        print(f"\n{theme.INFO}Stablecoin Breakdown (Merged):{theme.RESET}")
        symbol_totals = {}
        dust_stables_total = 0.0
        for symbol in merged_stables:
            symbol_total = sum(chain_data["usd"] for chain_data in merged_stables[symbol].values())
            if abs(symbol_total) < 10:  # Use absolute value for dust threshold
                dust_stables_total += symbol_total
            else:
                symbol_totals[symbol] = symbol_total
                    
        # Calculate total excluding negative values for percentage calculation
        total_stables_positive = sum(value for value in symbol_totals.values() if value > 0)
        total_stables = sum(symbol_totals.values()) + dust_stables_total
        
        for symbol, symbol_total in sorted(symbol_totals.items(), key=lambda x: (x[1] < 0, -abs(x[1]))):
            # Check if token has negative total value
            is_negative_token = symbol_total < 0
            symbol_pct = round(symbol_total / total_stables_positive * 100, 1) if total_stables_positive and not is_negative_token else 0
            chains_for_symbol = list(merged_stables[symbol].keys())
            if len(chains_for_symbol) == 1:
                chain = chains_for_symbol[0]
                chain_data = merged_stables[symbol][chain]
                icon = chain_icons.get(chain, "üîó")
                if chain_data["has_protocol_data"] and chain_data["protocols"]:
                    if len(chain_data["protocols"]) == 1:
                        (pname, ptype), p_usd = next(iter(chain_data["protocols"].items()))
                        # Check if we also have token data to show
                        token_only_usd = chain_data["token_usd"]
                        if token_only_usd > 0:
                            if is_negative_token:
                                print(f"  {symbol} ({icon} {chain}): {format_currency(chain_data['usd'])}")
                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                                print(f"    ‚Ä¢ {symbol}: {format_currency(token_only_usd)}")
                            else:
                                print(f"  {symbol} ({icon} {chain}): {format_currency(chain_data['usd'])} ({symbol_pct:.1f}%)")
                                p_pct = (p_usd / chain_data['usd'] * 100) if chain_data['usd'] else 0
                                token_pct = (token_only_usd / chain_data['usd'] * 100) if chain_data['usd'] else 0
                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                                print(f"    ‚Ä¢ {symbol}: {format_currency(token_only_usd)} ({token_pct:.1f}%)")
                        else:
                            if is_negative_token:
                                print(f"  {symbol} ({icon} {chain}): {format_currency(chain_data['usd'])} ‚Üê {pname} [{ptype}]")
                            else:
                                print(f"  {symbol} ({icon} {chain}): {format_currency(chain_data['usd'])} ({symbol_pct:.1f}%)  ‚Üê {pname} [{ptype}]")
                    else:
                        if is_negative_token:
                            print(f"  {symbol} ({icon} {chain}): {format_currency(chain_data['usd'])}")
                        else:
                            print(f"  {symbol} ({icon} {chain}): {format_currency(chain_data['usd'])} ({symbol_pct:.1f}%)")
                        for (pname, ptype), p_usd in sorted(chain_data["protocols"].items(), key=lambda x: -x[1]):
                            has_negative_protocols = any(p_data < 0 if isinstance(p_data, (int, float)) else (p_data.get("usd", 0) if isinstance(p_data, dict) else p_data) < 0 for p_data in chain_data["protocols"].values())
                            if is_negative_token or has_negative_protocols:
                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                            else:
                                p_pct = (p_usd / chain_data['usd'] * 100) if chain_data['usd'] else 0
                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                        # Show token-only value if it exists
                        token_only_usd = chain_data["token_usd"]
                        if token_only_usd > 0:
                            if is_negative_token:
                                print(f"    ‚Ä¢ {symbol}: {format_currency(token_only_usd)}")
                            else:
                                token_pct = (token_only_usd / chain_data['usd'] * 100) if chain_data['usd'] else 0
                                print(f"    ‚Ä¢ {symbol}: {format_currency(token_only_usd)} ({token_pct:.1f}%)")
                else:
                    if is_negative_token:
                        print(f"  {symbol} ({icon} {chain}): {format_currency(chain_data['usd'])}")
                    else:
                        print(f"  {symbol} ({icon} {chain}): {format_currency(chain_data['usd'])} ({symbol_pct:.1f}%)")
            else:
                if is_negative_token:
                    print(f"  {symbol}: {format_currency(symbol_total)}")
                else:
                    print(f"  {symbol}: {format_currency(symbol_total)} ({symbol_pct:.1f}%)")
                for chain in sorted(chains_for_symbol, key=lambda c: merged_stables[symbol][c]["usd"], reverse=True):
                    chain_data = merged_stables[symbol][chain]
                    chain_usd = chain_data["usd"]
                    if chain_usd <= 0:
                        continue
                    chain_pct = (chain_usd / symbol_total * 100) if symbol_total and not is_negative_token else 0
                    icon = chain_icons.get(chain, "üîó")
                    if chain_data["has_protocol_data"] and chain_data["protocols"]:
                        if len(chain_data["protocols"]) == 1:
                            (pname, ptype), p_usd = next(iter(chain_data["protocols"].items()))
                            # Check if we also have token data to show
                            token_only_usd = chain_data["token_usd"]
                            if token_only_usd > 0:
                                if is_negative_token:
                                    print(f"    {icon} {chain}: {format_currency(chain_usd)}")
                                    print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                                    print(f"      ‚Ä¢ {symbol}: {format_currency(token_only_usd)}")
                                else:
                                    print(f"    {icon} {chain}: {format_currency(chain_usd)} ({chain_pct:.1f}%)")
                                    p_pct = (p_usd / chain_usd * 100) if chain_usd else 0
                                    token_pct = (token_only_usd / chain_usd * 100) if chain_usd else 0
                                    print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                                    print(f"      ‚Ä¢ {symbol}: {format_currency(token_only_usd)} ({token_pct:.1f}%)")
                            else:
                                if is_negative_token:
                                    print(f"    {icon} {chain}: {format_currency(chain_usd)} ‚Üê {pname} [{ptype}]")
                                else:
                                    print(f"    {icon} {chain}: {format_currency(chain_usd)} ({chain_pct:.1f}%) ‚Üê {pname} [{ptype}]")
                        else:
                            if is_negative_token:
                                print(f"    {icon} {chain}: {format_currency(chain_usd)}")
                            else:
                                print(f"    {icon} {chain}: {format_currency(chain_usd)} ({chain_pct:.1f}%)")
                            # Show protocol entries
                            for (pname, ptype), p_data in sorted(chain_data["protocols"].items(), key=lambda x: -x[1]["usd"] if isinstance(x[1], dict) else -x[1]):
                                # Extract USD value from p_data
                                p_usd = p_data["usd"] if isinstance(p_data, dict) else p_data
                                has_negative_protocols = any(p_data < 0 if isinstance(p_data, (int, float)) else (p_data.get("usd", 0) if isinstance(p_data, dict) else p_data) < 0 for p_data in chain_data["protocols"].values())
                                if is_negative_token or has_negative_protocols:
                                    print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                                else:
                                    p_pct = (p_usd / chain_usd * 100) if chain_usd else 0
                                    print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                            # Show token-only value if it exists
                            token_only_usd = chain_data["token_usd"]
                            if token_only_usd > 0:
                                if is_negative_token:
                                    print(f"      ‚Ä¢ {symbol}: {format_currency(token_only_usd)}")
                                else:
                                    token_pct = (token_only_usd / chain_usd * 100) if chain_usd else 0
                                    print(f"      ‚Ä¢ {symbol}: {format_currency(token_only_usd)} ({token_pct:.1f}%)")
                    else:
                        if is_negative_token:
                            print(f"    {icon} {chain}: {format_currency(chain_usd)}")
                        else:
                            print(f"    {icon} {chain}: {format_currency(chain_usd)} ({chain_pct:.1f}%)")
        if dust_stables_total > 0:
            dust_percentage = (dust_stables_total / total_stables_positive * 100) if total_stables_positive and dust_stables_total > 0 else 0
            print(f"  {theme.SUBTLE}Dust stables (<$10): {format_currency(dust_stables_total)} ({dust_percentage:.1f}%){theme.RESET}")
        print(f"  {theme.ACCENT}Total Stables: {format_currency(total_stables)}{theme.RESET}")
        return total_stables
    return 0


def _display_merged_nonstable_breakdown(
    tokens: List[Dict[str, Any]],
    protocols: List[Dict[str, Any]],
    *,
    stable_total: Optional[float] = None,
):
    """Helper function to display merged non-stable breakdown from both token and protocol data."""
    from utils.display_theme import theme
    from utils.helpers import format_currency
    
    stable_bases = {'USDC', 'USDT', 'DAI', 'FDUSD', 'USDE', 'FRAX', 'TUSD', 'PYUSD', 'GUSD', 'PAX', 'BUSD', 'GHO', 'CRVUSD'}
    stable_patterns = ['USD']
    chain_icons = {"Ethereum": "‚ü†", "Arbitrum": "üîµ", "Polygon": "üü£", "Base": "üî∑", "Optimism": "üî¥", "Solana": "üåû", "Sonic": "‚ö°", "Soneium": "üü°", "Linea": "üü¢", "Ink": "üñãÔ∏è", "Lisk": "üî∂", "Unichain": "ü¶Ñ", "Gravity": "üåç", "Lens": "üì∑"}
    
    def _normalize_symbol(symbol: str) -> str:
        return (symbol or "").replace(" ", "").upper()

    def _is_base_stable(token: str) -> bool:
        clean = _normalize_symbol(token)
        if not clean:
            return False
        if clean in stable_bases:
            return True
        for pat in stable_patterns:
            if pat in clean:
                return True
        return False

    def is_stable(symbol: str) -> bool:
        clean = _normalize_symbol(symbol)
        if '+' in clean:
            parts = [part for part in clean.split('+') if part]
            return bool(parts) and all(_is_base_stable(part) for part in parts)
        if '/' in clean or '-' in clean:
            return False
        return _is_base_stable(clean)

    def is_pool_stable(symbol: str) -> bool:
        clean = _normalize_symbol(symbol)
        if '+' in clean:
            parts = [part for part in clean.split('+') if part]
            return bool(parts) and all(_is_base_stable(part) for part in parts)
        if '/' in clean or '-' in clean:
            return False
        return _is_base_stable(clean)
    
    compute_stable_total = stable_total is None
    computed_stable_total = 0.0

    # 1. Collect non-stable tokens from token breakdown
    token_nonstables = {}  # symbol -> {chain -> {"usd": float, "amt": float}}
    for token in tokens:
        symbol = token.get('symbol', '').upper()
        chain = token.get('chain', 'unknown').capitalize()
        value = token.get('usd_value', 0)
        amount = token.get('amount', 0)
        category = token.get('category', 'other_crypto')
        
        # Check if token is stable
        token_is_stable = is_stable(symbol) or category == 'stable'
        
        # Only collect non-stable tokens
        if token_is_stable:
            if compute_stable_total:
                computed_stable_total += value
            continue

        if symbol not in token_nonstables:
            token_nonstables[symbol] = {}
        if chain not in token_nonstables[symbol]:
            token_nonstables[symbol][chain] = {"usd": 0, "amt": 0}
        token_nonstables[symbol][chain]["usd"] += value
        token_nonstables[symbol][chain]["amt"] += amount
    
    # 2. Collect non-stable tokens from protocol breakdown
    protocol_nonstables = {}  # symbol -> {chain -> {(protocol, type) -> usd}}
    protocol_nonstable_totals = {}  # symbol -> {chain -> total_usd}
    for proto in protocols:
        chain = proto.get('chain', 'unknown').capitalize()
        proto_name = proto.get('name', 'Unknown')
        for pos in proto.get('positions', []):
            raw = (pos.get('asset') or pos.get('label') or '').strip()
            parts = raw.split()
            if len(parts) > 1 and any(ch.isdigit() for ch in parts[0]):
                symbol = parts[-1].upper()
            else:
                symbol = raw.upper()
            usd = pos.get('usd_value', pos.get('value', 0)) or 0
            try:
                usd = float(usd)
            except Exception:
                usd = 0
            
            # Extract amount from protocol position
            amount = pos.get('amount', 0) or 0
            try:
                amount = float(amount)
            except Exception:
                amount = 0
                
            ptype = pos.get('header_type', '-') or '-'
            is_borrowed = str(ptype).lower() == 'borrowed'

            if is_pool_stable(symbol):
                if compute_stable_total:
                    adjustment = -usd if is_borrowed else usd
                    computed_stable_total += adjustment
                continue

            if symbol not in protocol_nonstables:
                protocol_nonstables[symbol] = {}
                protocol_nonstable_totals[symbol] = {}
            if chain not in protocol_nonstables[symbol]:
                protocol_nonstables[symbol][chain] = {}
                protocol_nonstable_totals[symbol][chain] = {"usd": 0, "amt": 0}
            if is_borrowed:
                protocol_nonstables[symbol][chain][(proto_name, ptype)] = protocol_nonstables[symbol][chain].get((proto_name, ptype), {"usd": 0, "amt": 0})
                protocol_nonstables[symbol][chain][(proto_name, ptype)]["usd"] -= usd
                protocol_nonstables[symbol][chain][(proto_name, ptype)]["amt"] -= amount
                protocol_nonstable_totals[symbol][chain]["usd"] -= usd
                protocol_nonstable_totals[symbol][chain]["amt"] -= amount
            else:
                protocol_nonstables[symbol][chain][(proto_name, ptype)] = protocol_nonstables[symbol][chain].get((proto_name, ptype), {"usd": 0, "amt": 0})
                protocol_nonstables[symbol][chain][(proto_name, ptype)]["usd"] += usd
                protocol_nonstables[symbol][chain][(proto_name, ptype)]["amt"] += amount
                protocol_nonstable_totals[symbol][chain]["usd"] += usd
                protocol_nonstable_totals[symbol][chain]["amt"] += amount

    if compute_stable_total:
        stable_total = computed_stable_total
    stable_total = stable_total or 0.0

    # 3. Merge both datasets by summing values for each (symbol, chain)
    merged_nonstables = {}  # symbol -> {chain -> {"usd": float, "amt": float, "protocols": dict, "has_protocol_data": bool, "token_usd": float, "token_amt": float}}
    all_symbols = set(token_nonstables.keys()) | set(protocol_nonstables.keys())
    for symbol in all_symbols:
        merged_nonstables[symbol] = {}
        chains = set(token_nonstables.get(symbol, {}).keys()) | set(protocol_nonstables.get(symbol, {}).keys())
        for chain in chains:
            token_data = token_nonstables.get(symbol, {}).get(chain, {"usd": 0, "amt": 0})
            token_usd = token_data["usd"]
            token_amt = token_data["amt"]
            proto_data = protocol_nonstable_totals.get(symbol, {}).get(chain, {"usd": 0, "amt": 0})
            proto_usd = proto_data["usd"]
            proto_amt = proto_data["amt"]
            total_usd = token_usd + proto_usd
            total_amt = token_amt + proto_amt
            has_protocol_data = chain in protocol_nonstables.get(symbol, {}) and bool(protocol_nonstables[symbol][chain])
            protocols_dict = protocol_nonstables.get(symbol, {}).get(chain, {}) if has_protocol_data else {}
            merged_nonstables[symbol][chain] = {
                "usd": total_usd,
                "amt": total_amt,
                "protocols": protocols_dict,
                "has_protocol_data": has_protocol_data,
                "token_usd": token_usd,
                "token_amt": token_amt
            }
    
    # 4. Display merged non-stable breakdown
    if merged_nonstables:
        print(f"\n{theme.INFO}Non-Stable Token Breakdown (Merged):{theme.RESET}")
        symbol_totals = {}
        dust_nonstables_total = 0.0
        for symbol in merged_nonstables:
            symbol_total = sum(chain_data["usd"] for chain_data in merged_nonstables[symbol].values())
            if abs(symbol_total) < 10:  # Use absolute value for dust threshold - increased to $10
                dust_nonstables_total += symbol_total
            else:
                symbol_totals[symbol] = symbol_total
                
        # Calculate total excluding negative values for percentage calculation
        total_nonstables_positive = sum(value for value in symbol_totals.values() if value > 0)
        total_nonstables = sum(symbol_totals.values()) + dust_nonstables_total
        
        # Fix percentage calculation: Use positive-only base when there are negative values
        # This ensures positive token percentages add up to 100% instead of over 100%
        has_negative_values = any(value < 0 for value in symbol_totals.values())
        if has_negative_values:
            # When there are negative values, use only positive values for percentage base
            percentage_base = total_nonstables_positive + max(0, dust_nonstables_total)
        else:
            # When all values are positive, use the full total
            percentage_base = total_nonstables if total_nonstables > 0 else total_nonstables_positive
        
        for symbol, symbol_total in sorted(symbol_totals.items(), key=lambda x: (x[1] < 0, -abs(x[1]))):
            # Check if token has negative total value
            is_negative_token = symbol_total < 0
            symbol_pct = round(symbol_total / percentage_base * 100, 1) if percentage_base and not is_negative_token else 0
            
            # Calculate total amount for this symbol across all chains
            total_amt = sum(chain_data["amt"] for chain_data in merged_nonstables[symbol].values())
            amt_str = f"{total_amt:.6f}".rstrip('0').rstrip('.') if total_amt < 1 else f"{total_amt:,.4f}".rstrip('0').rstrip('.')
            
            chains_for_symbol = list(merged_nonstables[symbol].keys())
            if len(chains_for_symbol) == 1:
                chain = chains_for_symbol[0]
                chain_data = merged_nonstables[symbol][chain]
                icon = chain_icons.get(chain, "üîó")
                if chain_data["has_protocol_data"] and chain_data["protocols"]:
                    if len(chain_data["protocols"]) == 1:
                        (pname, ptype), p_data = next(iter(chain_data["protocols"].items()))
                        p_usd = p_data["usd"] if isinstance(p_data, dict) else p_data
                        # Check if we also have token data to show
                        token_only_usd = chain_data["token_usd"]
                        if token_only_usd > 0:
                            if is_negative_token:
                                print(f"  {symbol} ({icon} {chain}): {amt_str} - {format_currency(chain_data['usd'])} ({symbol_pct:.1f}%)")
                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                                print(f"    ‚Ä¢ {symbol}: {format_currency(token_only_usd)}")
                            else:
                                print(f"  {symbol} ({icon} {chain}): {amt_str} - {format_currency(chain_data['usd'])} ({symbol_pct:.1f}%)")
                                p_pct = (p_usd / chain_data['usd'] * 100) if chain_data['usd'] else 0
                                token_pct = (token_only_usd / chain_data['usd'] * 100) if chain_data['usd'] else 0
                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                                print(f"    ‚Ä¢ {symbol}: {format_currency(token_only_usd)} ({token_pct:.1f}%)")
                        else:
                            if is_negative_token:
                                print(f"  {symbol} ({icon} {chain}): {amt_str} - {format_currency(chain_data['usd'])} ‚Üê {pname} [{ptype}]")
                            else:
                                print(f"  {symbol} ({icon} {chain}): {amt_str} - {format_currency(chain_data['usd'])} ({symbol_pct:.1f}%) ‚Üê {pname} [{ptype}]")
                    else:
                        print(f"  {symbol} ({icon} {chain}): {amt_str} - {format_currency(chain_data['usd'])} ({symbol_pct:.1f}%)")
                        for (pname, ptype), p_data in sorted(chain_data["protocols"].items(), key=lambda x: -x[1]["usd"] if isinstance(x[1], dict) else -x[1]):
                            p_usd = p_data["usd"] if isinstance(p_data, dict) else p_data
                            if is_negative_token:
                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                            else:
                                p_pct = (p_usd / chain_data['usd'] * 100) if chain_data['usd'] else 0
                                print(f"    ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                        # Show token-only value if it exists
                        token_only_usd = chain_data["token_usd"]
                        if token_only_usd > 0:
                            if is_negative_token:
                                print(f"    ‚Ä¢ {symbol}: {format_currency(token_only_usd)}")
                            else:
                                token_pct = (token_only_usd / chain_data['usd'] * 100) if chain_data['usd'] else 0
                                print(f"    ‚Ä¢ {symbol}: {format_currency(token_only_usd)} ({token_pct:.1f}%)")
                else:
                    if is_negative_token:
                        print(f"  {symbol} ({icon} {chain}): {amt_str} - {format_currency(chain_data['usd'])}")
                    else:
                        print(f"  {symbol} ({icon} {chain}): {amt_str} - {format_currency(chain_data['usd'])} ({symbol_pct:.1f}%)")
            else:
                print(f"  {symbol}: {amt_str} - {format_currency(symbol_total)} ({symbol_pct:.1f}%)")
                
                # Separate chains into displayed and "other" chains
                displayed_chains = []
                other_chains_usd = 0
                other_chains_amt = 0
                
                for chain in sorted(chains_for_symbol, key=lambda c: merged_nonstables[symbol][c]["usd"], reverse=True):
                    chain_data = merged_nonstables[symbol][chain]
                    chain_usd = chain_data["usd"]
                    if chain_usd == 0:  # Only skip if exactly zero, not negative
                        continue
                    
                    # Show top chains individually, group small ones as "Other chains"
                    # For negative positions, always show them individually
                    if len(displayed_chains) < 10 and (abs(chain_usd) >= 1 or chain_usd < 0):
                        displayed_chains.append(chain)
                    else:
                        other_chains_usd += chain_usd
                        other_chains_amt += chain_data["amt"]
                
                # Display individual chains
                for chain in displayed_chains:
                    chain_data = merged_nonstables[symbol][chain]
                    chain_usd = chain_data["usd"]
                    chain_pct = (chain_usd / symbol_total * 100) if symbol_total and not is_negative_token else 0
                    icon = chain_icons.get(chain, "üîó")
                    chain_amt = chain_data["amt"]
                    camt_str = f"{chain_amt:.6f}".rstrip('0').rstrip('.') if chain_amt < 1 else f"{chain_amt:,.4f}".rstrip('0').rstrip('.')
                    
                    if chain_data["has_protocol_data"] and chain_data["protocols"]:
                        if len(chain_data["protocols"]) == 1:
                            (pname, ptype), p_data = next(iter(chain_data["protocols"].items()))
                            p_usd = p_data["usd"] if isinstance(p_data, dict) else p_data
                            # Check if we also have token data to show
                            token_only_usd = chain_data["token_usd"]
                            if token_only_usd > 0:
                                if is_negative_token:
                                    print(f"    {icon} {chain}: {camt_str} - {format_currency(chain_usd)}")
                                    print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                                    print(f"      ‚Ä¢ {symbol}: {format_currency(token_only_usd)}")
                                else:
                                    print(f"    {icon} {chain}: {camt_str} - {format_currency(chain_usd)} ({chain_pct:.1f}%)")
                                    p_pct = (p_usd / chain_usd * 100) if chain_usd else 0
                                    token_pct = (token_only_usd / chain_usd * 100) if chain_usd else 0
                                    print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                                    print(f"      ‚Ä¢ {symbol}: {format_currency(token_only_usd)} ({token_pct:.1f}%)")
                            else:
                                if is_negative_token:
                                    print(f"    {icon} {chain}: {camt_str} - {format_currency(chain_usd)} ‚Üê {pname} [{ptype}]")
                                else:
                                    print(f"    {icon} {chain}: {camt_str} - {format_currency(chain_usd)} ({chain_pct:.1f}%) ‚Üê {pname} [{ptype}]")
                        else:
                            if is_negative_token:
                                print(f"    {icon} {chain}: {camt_str} - {format_currency(chain_usd)}")
                            else:
                                print(f"    {icon} {chain}: {camt_str} - {format_currency(chain_usd)} ({chain_pct:.1f}%)")
                            # Show protocol entries
                            for (pname, ptype), p_data in sorted(chain_data["protocols"].items(), key=lambda x: -x[1]["usd"] if isinstance(x[1], dict) else -x[1]):
                                p_usd = p_data["usd"] if isinstance(p_data, dict) else p_data
                                has_negative_protocols = any(p_data < 0 if isinstance(p_data, (int, float)) else (p_data.get("usd", 0) if isinstance(p_data, dict) else p_data) < 0 for p_data in chain_data["protocols"].values())
                                if is_negative_token or has_negative_protocols:
                                    print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)}")
                                else:
                                    p_pct = (p_usd / chain_usd * 100) if chain_usd else 0
                                    print(f"      ‚Ä¢ {pname} [{ptype}]: {format_currency(p_usd)} ({p_pct:.1f}%)")
                            # Show token-only value if it exists
                            token_only_usd = chain_data["token_usd"]
                            if token_only_usd > 0:
                                if is_negative_token:
                                    print(f"      ‚Ä¢ {symbol}: {format_currency(token_only_usd)}")
                                else:
                                    token_pct = (token_only_usd / chain_usd * 100) if chain_usd else 0
                                    print(f"      ‚Ä¢ {symbol}: {format_currency(token_only_usd)} ({token_pct:.1f}%)")
                    else:
                        if is_negative_token:
                            print(f"    {icon} {chain}: {camt_str} - {format_currency(chain_usd)}")
                        else:
                            print(f"    {icon} {chain}: {camt_str} - {format_currency(chain_usd)} ({chain_pct:.1f}%)")
                
                # Display "Other chains" if there are any
                if other_chains_usd > 0:
                    if is_negative_token:
                        print(f"    Other chains: {format_currency(other_chains_usd)}")
                    else:
                        other_pct = (other_chains_usd / symbol_total * 100) if symbol_total else 0
                        print(f"    Other chains: {format_currency(other_chains_usd)} ({other_pct:.1f}%)")
        
        if dust_nonstables_total > 0:
            dust_percentage = round(dust_nonstables_total / percentage_base * 100, 1) if percentage_base and dust_nonstables_total > 0 else 0
            print(f"  {theme.SUBTLE}Dust tokens (<$10): {format_currency(dust_nonstables_total)} ({dust_percentage:.1f}%){theme.RESET}")
        print(f"  {theme.ACCENT}Total Non-Stable: {format_currency(total_nonstables)}{theme.RESET}")
        
        # New Summary Statistics replacing the old non-stable summary
        print(f"\n{theme.INFO}üìä Portfolio Summary Statistics:{theme.RESET}")
        
        total_non_stable_value = total_nonstables
        total_portfolio_value = stable_total + total_non_stable_value
        
        # Portfolio Breakdown Summary
        print(f"\n  üìà Portfolio Breakdown Summary:")
        
        # Calculate net values for non-stable tokens with ETH/WETH netting
        net_symbol_totals = {}
        
        # Define wrapped token mappings
        wrapped_mappings = {
            'WETH': 'ETH',
            'WBTC': 'BTC',
            'WMATIC': 'MATIC',
            'WBNB': 'BNB',
            'WAVAX': 'AVAX',
            'WFTM': 'FTM',
            'WONE': 'ONE'
        }
        
        # First, get all symbols and their net values (including borrowed positions)
        for symbol, chains in merged_nonstables.items():
            net_value = 0.0
            net_amount = 0.0
            for chain, data in chains.items():
                net_value += data["usd"]
                net_amount += data["amt"]
            
            # Map wrapped tokens to their base tokens
            base_symbol = wrapped_mappings.get(symbol, symbol)
            
            # Only include if net value is meaningful
            if abs(net_value) >= 0.01:  # Avoid dust
                if base_symbol in net_symbol_totals:
                    net_symbol_totals[base_symbol] += net_value
                else:
                    net_symbol_totals[base_symbol] = net_value
        
        # Filter for tokens above $250 threshold (using absolute value for filtering but keeping sign)
        filtered_nonstables = {symbol: value for symbol, value in net_symbol_totals.items() if abs(value) >= 250}
        
        if filtered_nonstables:
            print(f"\n    üìà Major Non-Stable Positions (>$250):")
            for symbol, net_value in sorted(filtered_nonstables.items(), key=lambda x: abs(x[1]), reverse=True):
                if total_portfolio_value > 0:
                    portfolio_percentage = (abs(net_value) / total_portfolio_value * 100)
                    
                    # Calculate combined amount for base symbol (including wrapped versions)
                    total_amount = 0.0
                    symbols_to_check = [symbol] + [k for k, v in wrapped_mappings.items() if v == symbol]
                    
                    for check_symbol in symbols_to_check:
                        if check_symbol in merged_nonstables:
                            total_amount += sum(chain_data["amt"] for chain_data in merged_nonstables[check_symbol].values())
                    
                    amount_str = f"{total_amount:.6f}".rstrip('0').rstrip('.') if total_amount < 1 else f"{total_amount:,.4f}".rstrip('0').rstrip('.')
                    
                    # Handle borrowed/negative positions
                    if net_value < 0:
                        print(f"      ‚Ä¢ {symbol}: {amount_str} - {format_currency(net_value)} ({portfolio_percentage:.1f}% borrowed)")
                    else:
                        print(f"      ‚Ä¢ {symbol}: {amount_str} - {format_currency(net_value)} ({portfolio_percentage:.1f}%)")
        else:
            print(f"\n    üìà Major Non-Stable Positions (>$250): None")
        
        # Calculate other tokens (below $250 threshold) accounting for borrowed positions
        other_tokens_total = sum(value for symbol, value in net_symbol_totals.items() if abs(value) < 250)
        if abs(other_tokens_total) > 0.01:
            other_tokens_count = len([v for v in net_symbol_totals.values() if abs(v) < 250])
            if total_portfolio_value > 0:
                other_portfolio_percentage = (abs(other_tokens_total) / total_portfolio_value * 100)
                if other_tokens_total < 0:
                    print(f"    üìä Other tokens (<$250): {other_tokens_count} positions - {format_currency(other_tokens_total)} ({other_portfolio_percentage:.1f}% net borrowed)")
                else:
                    print(f"    üìä Other tokens (<$250): {other_tokens_count} positions - {format_currency(other_tokens_total)} ({other_portfolio_percentage:.1f}%)")
        
        # Portfolio Distribution Summary
        if total_portfolio_value > 0:
            stable_percentage = (stable_total / total_portfolio_value * 100)
            nonstable_percentage = (total_non_stable_value / total_portfolio_value * 100)
            calculated_nonstable_total = sum(net_symbol_totals.values()) or total_non_stable_value
            calculated_total = stable_total + calculated_nonstable_total
            
            print(f"\n    üí∞ Portfolio Distribution Summary:")
            print(f"      üîí Stablecoins: {format_currency(stable_total)} ({stable_percentage:.1f}%)")
            print(f"      üìà Non-Stable: {format_currency(calculated_nonstable_total)} ({nonstable_percentage:.1f}%)")
            print(f"      üìä Total Portfolio: {format_currency(calculated_total)}")
        
        # Additional useful summaries
        print(f"\n  üéØ Additional Insights:")
        
        # Chain diversification insight (portfolio-relative)
        chain_totals = {}
        
        # Add non-stable token values by chain
        for symbol, chains in merged_nonstables.items():
            for chain, data in chains.items():
                if chain not in chain_totals:
                    chain_totals[chain] = 0
                chain_totals[chain] += data["usd"]
        
        # Add stable token values by chain (recalculate from tokens and protocols)
        # From tokens
        for token in tokens:
            symbol = token.get('symbol', '').upper()
            chain = token.get('chain', 'unknown').capitalize()
            value = token.get('usd_value', 0)
            category = token.get('category', 'other_crypto')
            if is_stable(symbol) or category == 'stable':
                if chain not in chain_totals:
                    chain_totals[chain] = 0
                chain_totals[chain] += value
        
        # From protocols  
        for proto in protocols:
            chain = proto.get('chain', 'unknown').capitalize()
            for pos in proto.get('positions', []):
                raw = (pos.get('asset') or pos.get('label') or '').strip()
                parts = raw.split()
                if len(parts) > 1 and any(ch.isdigit() for ch in parts[0]):
                    symbol = parts[-1].upper()
                else:
                    symbol = raw.upper()
                usd = pos.get('usd_value', pos.get('value', 0)) or 0
                try:
                    usd = float(usd)
                except Exception:
                    usd = 0
                ptype = pos.get('header_type', '-') or '-'
                is_borrowed = str(ptype).lower() == 'borrowed'
                if is_pool_stable(symbol):
                    if chain not in chain_totals:
                        chain_totals[chain] = 0
                    if is_borrowed:
                        chain_totals[chain] -= usd
                    else:
                        chain_totals[chain] += usd
        
        if chain_totals and total_portfolio_value > 0:
            top_chain = max(chain_totals.items(), key=lambda x: abs(x[1]))
            chain_percentage = (abs(top_chain[1]) / total_portfolio_value * 100)
            chain_icon = {"Ethereum": "‚ü†", "Arbitrum": "üîµ", "Polygon": "üü£", "Base": "üî∑", "Optimism": "üî¥", "Solana": "üåû", "Sonic": "‚ö°", "Soneium": "üü°", "Linea": "üü¢", "Ink": "üñãÔ∏è", "Lisk": "üî∂", "Unichain": "ü¶Ñ", "Gravity": "üåç", "Lens": "üì∑"}.get(top_chain[0], "üîó")
            print(f"    ‚Ä¢ Primary Chain: {chain_icon} {top_chain[0]} ({format_currency(top_chain[1])}, {chain_percentage:.1f}% of portfolio)")
        
        return total_nonstables
